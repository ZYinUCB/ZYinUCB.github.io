<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>禅茶一味</title>
  
  <subtitle>明天再说的自留地</subtitle>
  <link href="http://zyyyyy.com/atom.xml" rel="self"/>
  
  <link href="http://zyyyyy.com/"/>
  <updated>2022-09-18T09:03:14.622Z</updated>
  <id>http://zyyyyy.com/</id>
  
  <author>
    <name>明天再说</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CMU15-445 lab02(Part 4)</title>
    <link href="http://zyyyyy.com/2022/09/16/lab2-4/"/>
    <id>http://zyyyyy.com/2022/09/16/lab2-4/</id>
    <published>2022-09-16T14:22:39.000Z</published>
    <updated>2022-09-18T09:03:14.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TASK-2-B-B-TREE-DATA-STRUCTURE-DELETION"><a href="#TASK-2-B-B-TREE-DATA-STRUCTURE-DELETION" class="headerlink" title="TASK #2.B - B+TREE DATA STRUCTURE (DELETION)"></a>TASK #2.B - B+TREE DATA STRUCTURE (DELETION)</h2><p>您的B+树索引需要支持删除。如果删除导致某些页面低于占用阈值，您的B+树索引应该正确地执行合并或重新分发。同样，你的B+树索引只能支持唯一键，你应该遵循TASK #2.A中的相同指导方针。</p><span id="more"></span><h3 id="Remove函数"><a href="#Remove函数" class="headerlink" title="Remove函数"></a>Remove函数</h3><ul><li>先判断树是否为空。</li><li>调用<code>FindLeafPageByOperation</code>函数找到待删除的节点（已上写锁）。</li><li>在leaf中删除key（如果不存在该key，则size不变）。</li><li>如果删除失败，解锁并unpin自己以及经过的所有节点。</li><li>如果删除成功，调用<code>CoalesceOrRedistribute</code>函数，进行合并或重分配（或不做处理）。</li><li>还需判断叶子节点是否需要删除。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPLUSTREE_TYPE::Remove</span><span class="params">(<span class="type">const</span> KeyType &amp;key, Transaction *transaction)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> [leaf_page, root_is_latched] = <span class="built_in">FindLeafPageByOperation</span>(key, Operation::DELETE, transaction);</span><br><span class="line">  LeafPage *leaf_node = <span class="built_in">reinterpret_cast</span>&lt;LeafPage *&gt;(leaf_page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">  <span class="type">int</span> old_size = leaf_node-&gt;<span class="built_in">GetSize</span>();</span><br><span class="line">  <span class="type">int</span> new_size = leaf_node-&gt;<span class="built_in">RemoveAndDeleteRecord</span>(key, comparator_);  <span class="comment">// 在leaf中删除key（如果不存在该key，则size不变）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除失败</span></span><br><span class="line">  <span class="keyword">if</span> (new_size == old_size) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root_is_latched) &#123;</span><br><span class="line">      root_latch_.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UnlockUnpinPages</span>(transaction);</span><br><span class="line"></span><br><span class="line">    leaf_page-&gt;<span class="built_in">WUnlatch</span>();</span><br><span class="line">    buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(leaf_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">false</span>);  <span class="comment">// unpin leaf page</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除成功，然后调用CoalesceOrRedistribute</span></span><br><span class="line">  <span class="type">bool</span> *pointer_root_is_latched = <span class="keyword">new</span> <span class="built_in">bool</span>(root_is_latched);</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> leaf_should_delete = <span class="built_in">CoalesceOrRedistribute</span>(leaf_node, transaction, pointer_root_is_latched);</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> unlock and unpin are finished in CoalesceOrRedistribute</span></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> root node must be unlocked in CoalesceOrRedistribute</span></span><br><span class="line">  <span class="built_in">assert</span>((*pointer_root_is_latched) == <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> pointer_root_is_latched; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (leaf_should_delete) &#123;</span><br><span class="line">    transaction-&gt;<span class="built_in">AddIntoDeletedPageSet</span>(leaf_page-&gt;<span class="built_in">GetPageId</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  leaf_page-&gt;<span class="built_in">WUnlatch</span>();</span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(leaf_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>);  <span class="comment">// unpin leaf page</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> ensure deleted pages have been unpined</span></span><br><span class="line">  <span class="comment">// 删除并清空deleted page set</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">page_id_t</span> page_id : *transaction-&gt;<span class="built_in">GetDeletedPageSet</span>()) &#123;</span><br><span class="line">    buffer_pool_manager_-&gt;<span class="built_in">DeletePage</span>(page_id);</span><br><span class="line">  &#125;</span><br><span class="line">  transaction-&gt;<span class="built_in">GetDeletedPageSet</span>()-&gt;<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CoalesceOrRedistribute函数"><a href="#CoalesceOrRedistribute函数" class="headerlink" title="CoalesceOrRedistribute函数"></a>CoalesceOrRedistribute函数</h3><ul><li>判断该叶子节点是否同时为根节点，如果是，调用<code>AdjustRoot</code>函数。</li><li>如果不需要合并或者重分配，直接返回false。</li><li>否则找到兄弟节点，优先找到前驱节点，判断是否重分配。</li><li>当kv总和能支撑两个Node，那么重新分配即可，不必删除node，重分配不影响上层，此时可unpin并解锁经过的所有节点。</li><li>如果需合并，调用<code>Coalesce</code>函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> N&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BPLUSTREE_TYPE::CoalesceOrRedistribute</span><span class="params">(N *node, Transaction *transaction, <span class="type">bool</span> *root_is_latched)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;<span class="built_in">IsRootPage</span>()) &#123;</span><br><span class="line">    <span class="type">bool</span> root_should_delete = <span class="built_in">AdjustRoot</span>(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*root_is_latched) &#123;</span><br><span class="line">      *root_is_latched = <span class="literal">false</span>;</span><br><span class="line">      root_latch_.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UnlockPages</span>(transaction);</span><br><span class="line">    <span class="keyword">return</span> root_should_delete;  <span class="comment">// <span class="doctag">NOTE:</span> size of root page can be less than min size</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不需要合并或者重分配，直接返回false</span></span><br><span class="line">  <span class="keyword">if</span> (node-&gt;<span class="built_in">GetSize</span>() &gt;= node-&gt;<span class="built_in">GetMinSize</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*root_is_latched) &#123;</span><br><span class="line">      *root_is_latched = <span class="literal">false</span>;</span><br><span class="line">      root_latch_.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UnlockPages</span>(transaction);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要合并或者重分配</span></span><br><span class="line">  <span class="comment">// 先获取node的parent page</span></span><br><span class="line">  Page *parent_page = buffer_pool_manager_-&gt;<span class="built_in">FetchPage</span>(node-&gt;<span class="built_in">GetParentPageId</span>());</span><br><span class="line">  InternalPage *parent = <span class="built_in">reinterpret_cast</span>&lt;InternalPage *&gt;(parent_page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获得node在parent的孩子指针(value)的index</span></span><br><span class="line">  <span class="type">int</span> index = parent-&gt;<span class="built_in">ValueIndex</span>(node-&gt;<span class="built_in">GetPageId</span>());</span><br><span class="line">  <span class="comment">// 寻找兄弟结点，尽量找到前一个结点(前驱结点)</span></span><br><span class="line">  <span class="type">page_id_t</span> sibling_page_id = parent-&gt;<span class="built_in">ValueAt</span>(index == <span class="number">0</span> ? <span class="number">1</span> : index - <span class="number">1</span>);</span><br><span class="line">  Page *sibling_page = buffer_pool_manager_-&gt;<span class="built_in">FetchPage</span>(sibling_page_id);</span><br><span class="line"></span><br><span class="line">  sibling_page-&gt;<span class="built_in">WLatch</span>();  <span class="comment">// 记得要锁住兄弟结点</span></span><br><span class="line"></span><br><span class="line">  N *sibling_node = <span class="built_in">reinterpret_cast</span>&lt;N *&gt;(sibling_page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Redistribute 当kv总和能支撑两个Node，那么重新分配即可，不必删除node</span></span><br><span class="line">  <span class="keyword">if</span> (node-&gt;<span class="built_in">GetSize</span>() + sibling_node-&gt;<span class="built_in">GetSize</span>() &gt;= node-&gt;<span class="built_in">GetMaxSize</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*root_is_latched) &#123;</span><br><span class="line">      *root_is_latched = <span class="literal">false</span>;</span><br><span class="line">      root_latch_.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Redistribute</span>(sibling_node, node, index);</span><br><span class="line"></span><br><span class="line">    buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(parent_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    sibling_page-&gt;<span class="built_in">WUnlatch</span>();</span><br><span class="line">    buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(sibling_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UnlockUnpinPages</span>(transaction);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// node不必被删除</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Coalesce 当sibling和node只能凑成一个Node，那么合并两个结点到sibling，删除node</span></span><br><span class="line">  <span class="comment">// Coalesce函数继续递归调用CoalesceOrRedistribute</span></span><br><span class="line">  <span class="type">bool</span> parent_should_delete =</span><br><span class="line">      <span class="built_in">Coalesce</span>(&amp;sibling_node, &amp;node, &amp;parent, index, transaction, root_is_latched);  <span class="comment">// 返回值是parent是否需要被删除</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>((*root_is_latched) == <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parent_should_delete) &#123;</span><br><span class="line">    transaction-&gt;<span class="built_in">AddIntoDeletedPageSet</span>(parent-&gt;<span class="built_in">GetPageId</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> parent unlock is finished in Coalesce</span></span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(parent_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  sibling_page-&gt;<span class="built_in">WUnlatch</span>();</span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(sibling_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// node需要被删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Redistribute函数"><a href="#Redistribute函数" class="headerlink" title="Redistribute函数"></a>Redistribute函数</h3><ul><li>node是之前刚被删除过一个key的结点。</li><li>index&#x3D;0，则neighbor是node后继结点。</li><li>index&gt;0，则neighbor是node前驱结点。</li><li>注意更新parent结点的相关kv对。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> N&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPLUSTREE_TYPE::Redistribute</span><span class="params">(N *neighbor_node, N *node, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">  Page *parent_page = buffer_pool_manager_-&gt;<span class="built_in">FetchPage</span>(node-&gt;<span class="built_in">GetParentPageId</span>());</span><br><span class="line">  InternalPage *parent = <span class="built_in">reinterpret_cast</span>&lt;InternalPage *&gt;(parent_page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node-&gt;<span class="built_in">IsLeafPage</span>()) &#123;</span><br><span class="line">    LeafPage *leaf_node = <span class="built_in">reinterpret_cast</span>&lt;LeafPage *&gt;(node);</span><br><span class="line">    LeafPage *neighbor_leaf_node = <span class="built_in">reinterpret_cast</span>&lt;LeafPage *&gt;(neighbor_node);</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// node -&gt; neighbor</span></span><br><span class="line">      <span class="comment">// move neighbor&#x27;s first to node&#x27;s end</span></span><br><span class="line">      neighbor_leaf_node-&gt;<span class="built_in">MoveFirstToEndOf</span>(leaf_node);</span><br><span class="line">      parent-&gt;<span class="built_in">SetKeyAt</span>(<span class="number">1</span>, neighbor_leaf_node-&gt;<span class="built_in">KeyAt</span>(<span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// neighbor -&gt; node</span></span><br><span class="line">      <span class="comment">// move neighbor&#x27;s last to node&#x27;s front</span></span><br><span class="line">      neighbor_leaf_node-&gt;<span class="built_in">MoveLastToFrontOf</span>(leaf_node);</span><br><span class="line">      parent-&gt;<span class="built_in">SetKeyAt</span>(index, leaf_node-&gt;<span class="built_in">KeyAt</span>(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    InternalPage *internal_node = <span class="built_in">reinterpret_cast</span>&lt;InternalPage *&gt;(node);</span><br><span class="line">    InternalPage *neighbor_internal_node = <span class="built_in">reinterpret_cast</span>&lt;InternalPage *&gt;(neighbor_node);</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// case: node(left) and neighbor(right)</span></span><br><span class="line">      <span class="comment">// set neighbor&#x27;s first key to parent&#x27;s second key（详见MoveFirstToEndOf函数）</span></span><br><span class="line">      <span class="comment">// move neighbor&#x27;s first to node&#x27;s end</span></span><br><span class="line">      neighbor_internal_node-&gt;<span class="built_in">MoveFirstToEndOf</span>(internal_node, parent-&gt;<span class="built_in">KeyAt</span>(<span class="number">1</span>), buffer_pool_manager_);</span><br><span class="line">      <span class="comment">// set parent&#x27;s second key to neighbor&#x27;s &quot;new&quot; first key</span></span><br><span class="line">      parent-&gt;<span class="built_in">SetKeyAt</span>(<span class="number">1</span>, neighbor_internal_node-&gt;<span class="built_in">KeyAt</span>(<span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// case: neighbor(left) and node(right)</span></span><br><span class="line">      <span class="comment">// MoveLastToFrontOf do this:</span></span><br><span class="line">      <span class="comment">// set node&#x27;s first key to parent&#x27;s index key（详见MoveLastToFrontOf函数）</span></span><br><span class="line">      <span class="comment">// move neighbor&#x27;s last to node&#x27;s front</span></span><br><span class="line">      neighbor_internal_node-&gt;<span class="built_in">MoveLastToFrontOf</span>(internal_node, parent-&gt;<span class="built_in">KeyAt</span>(index), buffer_pool_manager_);</span><br><span class="line">      <span class="comment">// set parent&#x27;s index key to node&#x27;s &quot;new&quot; first key</span></span><br><span class="line">      parent-&gt;<span class="built_in">SetKeyAt</span>(index, internal_node-&gt;<span class="built_in">KeyAt</span>(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="AdjustRoot函数"><a href="#AdjustRoot函数" class="headerlink" title="AdjustRoot函数"></a>AdjustRoot函数</h3><ul><li>old_root_node是内部结点，且大小为1。表示内部结点其实已经没有key了，要把它的孩子更新成新的根结点。</li><li>old_root_node是叶结点，且大小为0。直接更新root page id。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BPLUSTREE_TYPE::AdjustRoot</span><span class="params">(BPlusTreePage *old_root_node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Case 1: old_root_node是内部结点，且大小为1。表示内部结点其实已经没有key了，所以要把它的孩子更新成新的根结点</span></span><br><span class="line">  <span class="comment">// old_root_node (internal node) has only one size</span></span><br><span class="line">  <span class="keyword">if</span> (!old_root_node-&gt;<span class="built_in">IsLeafPage</span>() &amp;&amp; old_root_node-&gt;<span class="built_in">GetSize</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">    InternalPage *internal_node = <span class="built_in">reinterpret_cast</span>&lt;InternalPage *&gt;(old_root_node);</span><br><span class="line">    <span class="type">page_id_t</span> child_page_id = internal_node-&gt;<span class="built_in">RemoveAndReturnOnlyChild</span>();</span><br><span class="line">    root_page_id_ = child_page_id;</span><br><span class="line">    <span class="built_in">UpdateRootPageId</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// update parent page id of new root node</span></span><br><span class="line">    Page *new_root_page = buffer_pool_manager_-&gt;<span class="built_in">FetchPage</span>(root_page_id_);</span><br><span class="line">    InternalPage *new_root_node = <span class="built_in">reinterpret_cast</span>&lt;InternalPage *&gt;(new_root_page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">    new_root_node-&gt;<span class="built_in">SetParentPageId</span>(INVALID_PAGE_ID);</span><br><span class="line">    buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(new_root_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Case 2: old_root_node是叶结点，且大小为0。直接更新root page id</span></span><br><span class="line">  <span class="comment">// all elements deleted from the B+ tree</span></span><br><span class="line">  <span class="keyword">if</span> (old_root_node-&gt;<span class="built_in">IsLeafPage</span>() &amp;&amp; old_root_node-&gt;<span class="built_in">GetSize</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">    root_page_id_ = INVALID_PAGE_ID;</span><br><span class="line">    <span class="built_in">UpdateRootPageId</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Coalesce函数"><a href="#Coalesce函数" class="headerlink" title="Coalesce函数"></a>Coalesce函数</h3><ul><li><code>index</code>表示node在parent中的孩子指针(value)的下标。</li><li><code>key_index</code>表示：交换后的 node在parent中的孩子指针(value)的下标。</li><li>若index&#x3D;0，说明node为neighbor前驱，要保证neighbor为node的前驱，则交换变量neighbor和node，且key_index&#x3D;1。</li><li>分叶子节点和中间节点进行合并操作，记得叶子节点要更新链表。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> N&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BPLUSTREE_TYPE::Coalesce</span><span class="params">(N **neighbor_node, N **node,</span></span></span><br><span class="line"><span class="params"><span class="function">                              BPlusTreeInternalPage&lt;KeyType, <span class="type">page_id_t</span>, KeyComparator&gt; **parent, <span class="type">int</span> index,</span></span></span><br><span class="line"><span class="params"><span class="function">                              Transaction *transaction, <span class="type">bool</span> *root_is_latched)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> key_index = index;</span><br><span class="line">  <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">    std::<span class="built_in">swap</span>(neighbor_node, node);  <span class="comment">// 保证neighbor_node为node的前驱</span></span><br><span class="line">    key_index = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  KeyType middle_key = (*parent)-&gt;<span class="built_in">KeyAt</span>(key_index);  <span class="comment">// middle_key only used in internal_node-&gt;MoveAllTo</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Move items from node to neighbor_node</span></span><br><span class="line">  <span class="keyword">if</span> ((*node)-&gt;<span class="built_in">IsLeafPage</span>()) &#123;</span><br><span class="line">    LeafPage *leaf_node = <span class="built_in">reinterpret_cast</span>&lt;LeafPage *&gt;(*node);</span><br><span class="line">    LeafPage *neighbor_leaf_node = <span class="built_in">reinterpret_cast</span>&lt;LeafPage *&gt;(*neighbor_node);</span><br><span class="line">    leaf_node-&gt;<span class="built_in">MoveAllTo</span>(neighbor_leaf_node);</span><br><span class="line">    neighbor_leaf_node-&gt;<span class="built_in">SetNextPageId</span>(leaf_node-&gt;<span class="built_in">GetNextPageId</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    InternalPage *internal_node = <span class="built_in">reinterpret_cast</span>&lt;InternalPage *&gt;(*node);</span><br><span class="line">    InternalPage *neighbor_internal_node = <span class="built_in">reinterpret_cast</span>&lt;InternalPage *&gt;(*neighbor_node);</span><br><span class="line">    <span class="comment">// MoveAllTo do this: set node&#x27;s first key to middle_key and move node to neighbor</span></span><br><span class="line">    internal_node-&gt;<span class="built_in">MoveAllTo</span>(neighbor_internal_node, middle_key, buffer_pool_manager_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除node在parent中的kv信息</span></span><br><span class="line">  (*parent)-&gt;<span class="built_in">Remove</span>(key_index);  <span class="comment">// 注意，是key_index，不是index</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 因为parent中删除了kv对，所以递归调用CoalesceOrRedistribute函数判断parent结点是否需要被删除</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">CoalesceOrRedistribute</span>(*parent, transaction, root_is_latched);</span><br></pre></td></tr></table></figure><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><ul><li>本地测试</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ ./test/b_plus_tree_delete_test </span><br><span class="line">Running main() from gmock_main.cc</span><br><span class="line">[==========] Running 2 tests from 1 <span class="built_in">test</span> suite.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 2 tests from BPlusTreeTests</span><br><span class="line">[ RUN      ] BPlusTreeTests.DeleteTest1</span><br><span class="line">[       OK ] BPlusTreeTests.DeleteTest1 (0 ms)</span><br><span class="line">[ RUN      ] BPlusTreeTests.DeleteTest2</span><br><span class="line">[       OK ] BPlusTreeTests.DeleteTest2 (0 ms)</span><br><span class="line">[----------] 2 tests from BPlusTreeTests (1 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global <span class="built_in">test</span> environment tear-down</span><br><span class="line">[==========] 2 tests from 1 <span class="built_in">test</span> suite ran. (1 ms total)</span><br><span class="line">[  PASSED  ] 2 tests.</span><br></pre></td></tr></table></figure><ul><li>Gradescope测试</li></ul><img src="/2022/09/16/lab2-4/grade.jpg" class="">]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;TASK-2-B-B-TREE-DATA-STRUCTURE-DELETION&quot;&gt;&lt;a href=&quot;#TASK-2-B-B-TREE-DATA-STRUCTURE-DELETION&quot; class=&quot;headerlink&quot; title=&quot;TASK #2.B - B+TREE DATA STRUCTURE (DELETION)&quot;&gt;&lt;/a&gt;TASK #2.B - B+TREE DATA STRUCTURE (DELETION)&lt;/h2&gt;&lt;p&gt;您的B+树索引需要支持删除。如果删除导致某些页面低于占用阈值，您的B+树索引应该正确地执行合并或重新分发。同样，你的B+树索引只能支持唯一键，你应该遵循TASK #2.A中的相同指导方针。&lt;/p&gt;</summary>
    
    
    
    <category term="CMU15-445" scheme="http://zyyyyy.com/categories/CMU15-445/"/>
    
    
    <category term="数据库存储" scheme="http://zyyyyy.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/"/>
    
    <category term="B+ Tree" scheme="http://zyyyyy.com/tags/B-Tree/"/>
    
  </entry>
  
  <entry>
    <title>CMU15-445 lab02(Part 3)</title>
    <link href="http://zyyyyy.com/2022/09/14/lab2-3/"/>
    <id>http://zyyyyy.com/2022/09/14/lab2-3/</id>
    <published>2022-09-14T11:15:28.000Z</published>
    <updated>2022-09-16T16:07:04.602Z</updated>
    
    <content type="html"><![CDATA[<style>@import url(https://fonts.googleapis.com/css?family=Roboto);blockquote { /* color:#888; */ background-color: #f9f2f4; border-left: 0.2em solid #FA7298; padding: 1em 0.7em 1em 0.7em; position: relative; /* font-family: 'Roboto', sans-serif; */ line-height: 150%; border-radius: 3px; /* text-indent: 35px; */}</style><h2 id="Task-2-A-B-TREE-DATA-STRUCTURE-INSERTION-amp-POINT-SEARCH"><a href="#Task-2-A-B-TREE-DATA-STRUCTURE-INSERTION-amp-POINT-SEARCH" class="headerlink" title="Task 2.A - B+TREE DATA STRUCTURE (INSERTION &amp; POINT SEARCH)"></a>Task 2.A - B+TREE DATA STRUCTURE (INSERTION &amp; POINT SEARCH)</h2><blockquote>实现b_plus_tree.cpp/InsertIntoLeaf函数所涉及到的相关函数。</blockquote><p>您的B +树索引只能支持唯一键。 也就是说，当您尝试将具有重复键的键值对插入索引时，它应该返回false</p><p>对于checkpoint1，仅需要B + Tree索引支持插入（<code>Insert</code>）和点搜索（<code>GetValue</code>）。 您不需要实现删除操作。 插入后如果当前键&#x2F;值对的数量等于<code>max_size</code>，则应该正确执行分割。 由于任何写操作都可能导致B + Tree索引中的<code>root_page_id</code>发生更改，因此您有责任更新（src &#x2F; include &#x2F; storage &#x2F; page &#x2F; header_page.h）中的<code>root_page_id</code>，以确保索引在磁盘上具有持久性 。 在<code>BPlusTree</code>类中，我们已经为您实现了一个名为<code>UpdateRootPageId</code>的函数。 您需要做的就是在B + Tree索引的<code>root_page_id</code>更改时调用此函数。</p><p>您的B + Tree实现必须隐藏key&#x2F;value等的详细信息，建议使用如下结构：</p><span id="more"></span><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> KeyType,</span><br><span class="line">          <span class="keyword">typename</span> ValueType,</span><br><span class="line">          <span class="keyword">typename</span> KeyComparator&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BPlusTree</span>&#123;</span><br><span class="line">   <span class="comment">// ---</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些类别已经为你实现了</p><ul><li><p><code>KeyType</code>: The type of each key in the index. This will only be GenericKey, the actual size of GenericKey is specified and instantiated with a template argument and depends on the data type of indexed attribute.</p></li><li><p><code>ValueType</code>: The type of each value in the index. This will only be 64-bit RID.</p></li><li><p><code>KeyComparator</code>: The class used to compare whether two KeyType instances are less&#x2F;greater-than each other. These will be included in the KeyType implementation files.</p></li></ul><ol><li>你必须使用传入的<code>transaction</code>，把已经加锁的页面保存起来。</li><li>我们提供了读写锁存器的实现（src &#x2F; include &#x2F; common &#x2F; rwlatch.h）。 并且已经在页面头文件下添加了辅助函数来获取和释放<code>Latch</code>锁（src &#x2F; include &#x2F; storage &#x2F; page &#x2F; page.h）。</li></ol><h3 id="GetValue相关函数"><a href="#GetValue相关函数" class="headerlink" title="GetValue相关函数"></a>GetValue相关函数</h3><h4 id="GetValue"><a href="#GetValue" class="headerlink" title="GetValue()"></a>GetValue()</h4><ul><li>先找到leaf page，这里面会调用<code>FindLeafPageByOperation</code>函数。</li><li>在leaf page里找这个key，调用叶子结点的查找函数返回<code>value</code>。</li><li>同时需要考虑并发，这里先讨论查找操作并发。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BPLUSTREE_TYPE::GetValue</span><span class="params">(<span class="type">const</span> KeyType &amp;key, std::vector&lt;ValueType&gt; *result, Transaction *transaction)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先找到leaf page，这里面会调用`FindLeafPageByOperation`函数。</span></span><br><span class="line">  Page *leaf_page = <span class="built_in">FindLeafPageByOperation</span>(key, Operation::FIND, transaction).first;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在leaf page里找这个key</span></span><br><span class="line">  LeafPage *leaf_node = <span class="built_in">reinterpret_cast</span>&lt;LeafPage *&gt;(leaf_page-&gt;<span class="built_in">GetData</span>());  <span class="comment">// 记得加上GetData()</span></span><br><span class="line"></span><br><span class="line">  ValueType value&#123;&#125;;</span><br><span class="line">  <span class="type">bool</span> is_exist = leaf_node-&gt;<span class="built_in">Lookup</span>(key, &amp;value, comparator_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// page用完后记得unpin page</span></span><br><span class="line">  leaf_page-&gt;<span class="built_in">RUnlatch</span>();</span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(leaf_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">false</span>);  <span class="comment">// unpin leaf page</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!is_exist) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  result-&gt;<span class="built_in">push_back</span>(value);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="FindLeafPageByOperation"><a href="#FindLeafPageByOperation" class="headerlink" title="FindLeafPageByOperation()"></a>FindLeafPageByOperation()</h4><ul><li>对于查找操作，我们按照课堂上讲的规则，一步步加锁&#x2F;解锁。</li><li>查找操作运用的是读锁<code>RLatch</code>, 给下一层添加时立即解锁上一层。</li><li>我们从根节点遍历到叶子节点，返回已锁的目标page。</li><li><code>root_latch_</code>是为了维护root id不变。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function">std::pair&lt;Page *, <span class="type">bool</span>&gt; <span class="title">BPLUSTREE_TYPE::FindLeafPageByOperation</span><span class="params">(<span class="type">const</span> KeyType &amp;key, Operation operation,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                Transaction *transaction, <span class="type">bool</span> leftMost,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                <span class="type">bool</span> rightMost)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(operation == Operation::FIND ? !(leftMost &amp;&amp; rightMost) : transaction != <span class="literal">nullptr</span>);</span><br><span class="line">  root_latch_.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="type">bool</span> is_root_page_id_latched = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  Page *page = buffer_pool_manager_-&gt;<span class="built_in">FetchPage</span>(root_page_id_);</span><br><span class="line">  BPlusTreePage *node = <span class="built_in">reinterpret_cast</span>&lt;BPlusTreePage *&gt;(page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (operation == Operation::FIND) &#123;</span><br><span class="line">    page-&gt;<span class="built_in">RLatch</span>();</span><br><span class="line">    is_root_page_id_latched = <span class="literal">false</span>;</span><br><span class="line">    root_latch_.<span class="built_in">unlock</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    page-&gt;<span class="built_in">WLatch</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsSafe</span>(node, operation)) &#123;</span><br><span class="line">      is_root_page_id_latched = <span class="literal">false</span>;</span><br><span class="line">      root_latch_.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!node-&gt;<span class="built_in">IsLeafPage</span>()) &#123;</span><br><span class="line">    InternalPage *i_node = <span class="built_in">reinterpret_cast</span>&lt;InternalPage *&gt;(node);</span><br><span class="line"></span><br><span class="line">    <span class="type">page_id_t</span> child_node_page_id;</span><br><span class="line">    <span class="keyword">if</span> (leftMost) &#123;</span><br><span class="line">      child_node_page_id = i_node-&gt;<span class="built_in">ValueAt</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightMost) &#123;</span><br><span class="line">      child_node_page_id = i_node-&gt;<span class="built_in">ValueAt</span>(i_node-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      child_node_page_id = i_node-&gt;<span class="built_in">Lookup</span>(key, comparator_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> child_page = buffer_pool_manager_-&gt;<span class="built_in">FetchPage</span>(child_node_page_id);</span><br><span class="line">    <span class="keyword">auto</span> child_node = <span class="built_in">reinterpret_cast</span>&lt;BPlusTreePage *&gt;(child_page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (operation == Operation::FIND) &#123;</span><br><span class="line">      child_page-&gt;<span class="built_in">RLatch</span>();</span><br><span class="line">      page-&gt;<span class="built_in">RUnlatch</span>();</span><br><span class="line">      buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      child_page-&gt;<span class="built_in">WLatch</span>();</span><br><span class="line">      transaction-&gt;<span class="built_in">AddIntoPageSet</span>(page);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">IsSafe</span>(child_node, operation)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_root_page_id_latched) &#123;</span><br><span class="line">          is_root_page_id_latched = <span class="literal">false</span>;</span><br><span class="line">          root_latch_.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">UnlockUnpinPages</span>(transaction);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page = child_page;</span><br><span class="line">    node = child_node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(page, is_root_page_id_latched);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StartNewTree函数"><a href="#StartNewTree函数" class="headerlink" title="StartNewTree函数"></a>StartNewTree函数</h3><ul><li>创建一个新的根节点</li><li>先去缓冲池申请一个new page，作为root page（该函数会分配一个page id）</li><li>page id赋值给root page id，并插入header page的root page id</li><li>使用leaf page的Insert函数插入(key,value)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPLUSTREE_TYPE::StartNewTree</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> ValueType &amp;value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先去缓冲池申请一个new page，作为root page</span></span><br><span class="line">  <span class="type">page_id_t</span> new_page_id = INVALID_PAGE_ID;</span><br><span class="line">  Page *root_page = buffer_pool_manager_-&gt;<span class="built_in">NewPage</span>(&amp;new_page_id);  <span class="comment">// 注意new page的pin_count=1，之后记得unpin page</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nullptr</span> == root_page) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;out of memory&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// page id赋值给root page id，并插入header page的root page id</span></span><br><span class="line">  root_page_id_ = new_page_id;</span><br><span class="line">  <span class="built_in">UpdateRootPageId</span>(<span class="number">1</span>);  <span class="comment">// insert root page id in header page</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用leaf page的Insert函数插入(key,value)</span></span><br><span class="line">  LeafPage *root_node = <span class="built_in">reinterpret_cast</span>&lt;LeafPage *&gt;(root_page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">  root_node-&gt;<span class="built_in">Init</span>(new_page_id, INVALID_PAGE_ID, leaf_max_size_);</span><br><span class="line">  root_node-&gt;<span class="built_in">Insert</span>(key, value, comparator_);</span><br><span class="line">  <span class="comment">// unpin root page</span></span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(root_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>);  <span class="comment">// 注意：这里dirty要置为true！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Insert函数"><a href="#Insert函数" class="headerlink" title="Insert函数"></a>Insert函数</h3><ul><li>先判断插入时树是否为空，如果是空，建立一个新树，再插入。</li><li>注意新建根节点时要加锁。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BPLUSTREE_TYPE::Insert</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> ValueType &amp;value, Transaction *transaction)</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(root_latch_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">      <span class="built_in">StartNewTree</span>(key, value);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">InsertIntoLeaf</span>(key, value, transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InsertIntoLeaf相关函数"><a href="#InsertIntoLeaf相关函数" class="headerlink" title="InsertIntoLeaf相关函数"></a>InsertIntoLeaf相关函数</h3><h4 id="FindLeafPageByOperation-1"><a href="#FindLeafPageByOperation-1" class="headerlink" title="FindLeafPageByOperation()"></a>FindLeafPageByOperation()</h4><ul><li>这里会用到<code>Insert</code>命令和写锁。</li><li>从根节点开始由上至下逐步加入<code>WLatch</code>。</li><li>每一层都判断一次当前节点是否安全，即满足<code>node-&gt;GetSize() &lt; node-&gt;GetMaxSize() - 1</code>。</li><li>若安全，解锁并unpin所有经过的父节点。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function">std::pair&lt;Page *, <span class="type">bool</span>&gt; <span class="title">BPLUSTREE_TYPE::FindLeafPageByOperation</span><span class="params">(<span class="type">const</span> KeyType &amp;key, Operation operation,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                Transaction *transaction, <span class="type">bool</span> leftMost,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                <span class="type">bool</span> rightMost)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(operation == Operation::FIND ? !(leftMost &amp;&amp; rightMost) : transaction != <span class="literal">nullptr</span>);</span><br><span class="line">  root_latch_.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="type">bool</span> is_root_page_id_latched = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  Page *page = buffer_pool_manager_-&gt;<span class="built_in">FetchPage</span>(root_page_id_);</span><br><span class="line">  BPlusTreePage *node = <span class="built_in">reinterpret_cast</span>&lt;BPlusTreePage *&gt;(page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (operation == Operation::FIND) &#123;</span><br><span class="line">    page-&gt;<span class="built_in">RLatch</span>();</span><br><span class="line">    is_root_page_id_latched = <span class="literal">false</span>;</span><br><span class="line">    root_latch_.<span class="built_in">unlock</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    page-&gt;<span class="built_in">WLatch</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsSafe</span>(node, operation)) &#123;</span><br><span class="line">      is_root_page_id_latched = <span class="literal">false</span>;</span><br><span class="line">      root_latch_.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!node-&gt;<span class="built_in">IsLeafPage</span>()) &#123;</span><br><span class="line">    InternalPage *i_node = <span class="built_in">reinterpret_cast</span>&lt;InternalPage *&gt;(node);</span><br><span class="line"></span><br><span class="line">    <span class="type">page_id_t</span> child_node_page_id;</span><br><span class="line">    <span class="keyword">if</span> (leftMost) &#123;</span><br><span class="line">      child_node_page_id = i_node-&gt;<span class="built_in">ValueAt</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightMost) &#123;</span><br><span class="line">      child_node_page_id = i_node-&gt;<span class="built_in">ValueAt</span>(i_node-&gt;<span class="built_in">GetSize</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      child_node_page_id = i_node-&gt;<span class="built_in">Lookup</span>(key, comparator_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> child_page = buffer_pool_manager_-&gt;<span class="built_in">FetchPage</span>(child_node_page_id);</span><br><span class="line">    <span class="keyword">auto</span> child_node = <span class="built_in">reinterpret_cast</span>&lt;BPlusTreePage *&gt;(child_page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (operation == Operation::FIND) &#123;</span><br><span class="line">      child_page-&gt;<span class="built_in">RLatch</span>();</span><br><span class="line">      page-&gt;<span class="built_in">RUnlatch</span>();</span><br><span class="line">      buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      child_page-&gt;<span class="built_in">WLatch</span>();</span><br><span class="line">      transaction-&gt;<span class="built_in">AddIntoPageSet</span>(page);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">IsSafe</span>(child_node, operation)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_root_page_id_latched) &#123;</span><br><span class="line">          is_root_page_id_latched = <span class="literal">false</span>;</span><br><span class="line">          root_latch_.<span class="built_in">unlock</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">UnlockUnpinPages</span>(transaction);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page = child_page;</span><br><span class="line">    node = child_node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(page, is_root_page_id_latched);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="InsertIntoLeaf"><a href="#InsertIntoLeaf" class="headerlink" title="InsertIntoLeaf()"></a>InsertIntoLeaf()</h4><ul><li>先找到待插入节点（已上锁），调用叶子节点的<code>Insert</code>。</li><li>如果待插入的<code>key</code>已存在，Unpin且解锁当前及所有祖先节点。</li><li>如果不存在，且无需分裂，解锁并unpin当前页面，返回True。</li><li>如果需分裂，调用<code>split</code>和<code>InsertIntoParent</code>函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BPLUSTREE_TYPE::InsertIntoLeaf</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> ValueType &amp;value, Transaction *transaction)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1 find the leaf page as insertion target</span></span><br><span class="line">  <span class="keyword">auto</span> [leaf_page, root_is_latched] = <span class="built_in">FindLeafPageByOperation</span>(key, Operation::INSERT, transaction);</span><br><span class="line"></span><br><span class="line">  LeafPage *leaf_node = <span class="built_in">reinterpret_cast</span>&lt;LeafPage *&gt;(leaf_page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">  <span class="type">int</span> size = leaf_node-&gt;<span class="built_in">GetSize</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2 the key not exist, so we can insert (key,value) to leaf node</span></span><br><span class="line">  <span class="type">int</span> new_size = leaf_node-&gt;<span class="built_in">Insert</span>(key, value, comparator_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if (is_exist) &#123;</span></span><br><span class="line">  <span class="keyword">if</span> (new_size == size) &#123;</span><br><span class="line">    <span class="comment">// assert(root_is_latched_ == true);</span></span><br><span class="line">    <span class="keyword">if</span> (root_is_latched) &#123;</span><br><span class="line">      <span class="comment">// LOG_INFO(&quot;Before END InsertIntoLeaf duplicate keys: root_latch_.unlock()&quot;);</span></span><br><span class="line">      root_latch_.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UnlockUnpinPages</span>(transaction);  <span class="comment">// 此函数中会释放叶子的所有现在被锁住的祖先（不包括叶子）</span></span><br><span class="line">    <span class="comment">// assert(root_is_latched_ == false);</span></span><br><span class="line">    leaf_page-&gt;<span class="built_in">WUnlatch</span>();</span><br><span class="line">    buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(leaf_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">false</span>);  <span class="comment">// unpin leaf page</span></span><br><span class="line">    <span class="comment">// LOG_INFO(&quot;END InsertIntoLeaf duplicate keys! key=%ld thread=%lu&quot;, key.ToString(), getThreadId());</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; leaf_node-&gt;<span class="built_in">GetMaxSize</span>()) &#123;</span><br><span class="line">    <span class="comment">// UnlockUnpinPages(transaction, Operation::INSERT);  // DEBUG 疑问：此处是否需要释放所有祖先节点的锁？</span></span><br><span class="line">    <span class="comment">// 似乎不需要，因为如果叶子节点插入后小于maxsize，说明其父节点在之前在findLeafPage就已经释放过锁了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root_is_latched) &#123;</span><br><span class="line">      <span class="comment">// LOG_INFO(&quot;Before END InsertIntoLeaf no split: root_latch_.unlock()&quot;);</span></span><br><span class="line">      root_latch_.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    leaf_page-&gt;<span class="built_in">WUnlatch</span>();</span><br><span class="line">    buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(leaf_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>);  <span class="comment">// unpin leaf page</span></span><br><span class="line">    <span class="comment">// LOG_INFO(&quot;END InsertIntoLeaf no split! key=%ld thread=%lu&quot;, key.ToString(), getThreadId());  // DEBUG</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// new_size &gt;= leaf_node-&gt;GetMaxSize()</span></span><br><span class="line">  LeafPage *new_leaf_node = <span class="built_in">Split</span>(leaf_node);  <span class="comment">// pin new leaf node</span></span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> *pointer_root_is_latched = <span class="keyword">new</span> <span class="built_in">bool</span>(root_is_latched);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">InsertIntoParent</span>(leaf_node, new_leaf_node-&gt;<span class="built_in">KeyAt</span>(<span class="number">0</span>), new_leaf_node, transaction,</span><br><span class="line">                   pointer_root_is_latched);  <span class="comment">// 此函数内将会 W Unlatch</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>((*pointer_root_is_latched) == <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> pointer_root_is_latched;</span><br><span class="line"></span><br><span class="line">  leaf_page-&gt;<span class="built_in">WUnlatch</span>();</span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(leaf_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>);      <span class="comment">// unpin leaf page</span></span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(new_leaf_node-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>);  <span class="comment">// DE<span class="doctag">BUG:</span> unpin new leaf node</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Split"><a href="#Split" class="headerlink" title="Split()"></a>Split()</h4><ul><li>拆分函数，插入时将节点分裂。</li><li>如果是叶子节点，调用叶子节点的<code>MoveHalfTo</code>函数，还需设置链表。</li><li>如果是非叶子节点，调用中间节点的<code>MoveHalfTo</code>函数。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">INDEX_TEMPLATE_ARGUMENTS</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> N&gt;</span><br><span class="line"><span class="function">N *<span class="title">BPLUSTREE_TYPE::Split</span><span class="params">(N *node)</span> </span>&#123;</span><br><span class="line">  <span class="type">page_id_t</span> new_page_id = INVALID_PAGE_ID;</span><br><span class="line">  Page *new_page = buffer_pool_manager_-&gt;<span class="built_in">NewPage</span>(&amp;new_page_id);  <span class="comment">// 注意new page的pin_count=1，之后记得unpin page</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">nullptr</span> == new_page) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;out of memory&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  N *new_node = <span class="built_in">reinterpret_cast</span>&lt;N *&gt;(new_page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node-&gt;<span class="built_in">IsLeafPage</span>()) &#123;  <span class="comment">// leaf page</span></span><br><span class="line">    LeafPage *old_leaf_node = <span class="built_in">reinterpret_cast</span>&lt;LeafPage *&gt;(node);</span><br><span class="line">    LeafPage *new_leaf_node = <span class="built_in">reinterpret_cast</span>&lt;LeafPage *&gt;(new_node);</span><br><span class="line">    new_leaf_node-&gt;<span class="built_in">Init</span>(new_page_id, node-&gt;<span class="built_in">GetParentPageId</span>(), leaf_max_size_);</span><br><span class="line"></span><br><span class="line">    old_leaf_node-&gt;<span class="built_in">MoveHalfTo</span>(new_leaf_node);</span><br><span class="line">    <span class="comment">// 更新叶子层的链表，示意如下：</span></span><br><span class="line">    <span class="comment">// 原来：old node ---&gt; next node</span></span><br><span class="line">    <span class="comment">// 最新：old node ---&gt; new node ---&gt; next node</span></span><br><span class="line">    new_leaf_node-&gt;<span class="built_in">SetNextPageId</span>(old_leaf_node-&gt;<span class="built_in">GetNextPageId</span>());  <span class="comment">// 完成连接new node ---&gt; next node</span></span><br><span class="line">    old_leaf_node-&gt;<span class="built_in">SetNextPageId</span>(new_leaf_node-&gt;<span class="built_in">GetPageId</span>());      <span class="comment">// 完成连接old node ---&gt; new node</span></span><br><span class="line">    new_node = <span class="built_in">reinterpret_cast</span>&lt;N *&gt;(new_leaf_node);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// internal page</span></span><br><span class="line">    InternalPage *old_internal_node = <span class="built_in">reinterpret_cast</span>&lt;InternalPage *&gt;(node);</span><br><span class="line">    InternalPage *new_internal_node = <span class="built_in">reinterpret_cast</span>&lt;InternalPage *&gt;(new_node);</span><br><span class="line">    new_internal_node-&gt;<span class="built_in">Init</span>(new_page_id, node-&gt;<span class="built_in">GetParentPageId</span>(), internal_max_size_);</span><br><span class="line">    <span class="comment">// old_internal_node右半部分 移动至 new_internal_node</span></span><br><span class="line">    <span class="comment">// new_node（原old_node的右半部分）的所有孩子结点的父指针更新为指向new_node</span></span><br><span class="line">    old_internal_node-&gt;<span class="built_in">MoveHalfTo</span>(new_internal_node, buffer_pool_manager_);</span><br><span class="line">    new_node = <span class="built_in">reinterpret_cast</span>&lt;N *&gt;(new_internal_node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// fetch page and new page need to unpin page (do it outside)</span></span><br><span class="line">  <span class="keyword">return</span> new_node;  <span class="comment">// 注意，此时new_node还没有unpin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="InsertIntoParent"><a href="#InsertIntoParent" class="headerlink" title="InsertIntoParent()"></a>InsertIntoParent()</h4><ul><li>拆分(Split)后，向上找到old_node的父结点。</li><li>将new_node的第一个key插入到父结点，其位置在 父结点指向old_node的孩子指针之后。</li><li>如果插入后&gt;&#x3D;maxsize，则必须继续拆分父结点，然后在其父结点的父结点再插入，即需要递归。</li><li>直到找到的old_node为根结点时，结束递归（此时将会新建一个根R，关键字为key，old_node和new_node为其孩子）。</li><li>注意：本函数执行完毕后，new node和old node都需要在函数外面进行unpin。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPLUSTREE_TYPE::InsertIntoParent</span><span class="params">(BPlusTreePage *old_node, <span class="type">const</span> KeyType &amp;key, BPlusTreePage *new_node,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      Transaction *transaction, <span class="type">bool</span> *root_is_latched)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1 old_node是根结点，那么整棵树直接升高一层</span></span><br><span class="line">  <span class="comment">// 具体操作是创建一个新结点R当作根结点，其关键字为key，左右孩子结点分别为old_node和new_node</span></span><br><span class="line">  <span class="keyword">if</span> (old_node-&gt;<span class="built_in">IsRootPage</span>()) &#123;  <span class="comment">// old node为根结点</span></span><br><span class="line">    <span class="type">page_id_t</span> new_page_id = INVALID_PAGE_ID;</span><br><span class="line">    Page *new_page = buffer_pool_manager_-&gt;<span class="built_in">NewPage</span>(&amp;new_page_id);  <span class="comment">// 这里应该是NewPage，不是FetchPage！</span></span><br><span class="line">    root_page_id_ = new_page_id;</span><br><span class="line"></span><br><span class="line">    InternalPage *new_root_node = <span class="built_in">reinterpret_cast</span>&lt;InternalPage *&gt;(new_page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">    new_root_node-&gt;<span class="built_in">Init</span>(new_page_id, INVALID_PAGE_ID, internal_max_size_);  <span class="comment">// 注意初始化parent page id和max_size</span></span><br><span class="line">    <span class="comment">// 修改新的根结点的孩子指针，即array[0].second指向old_node，array[1].second指向new_node；对于array[1].first则赋值为key</span></span><br><span class="line">    new_root_node-&gt;<span class="built_in">PopulateNewRoot</span>(old_node-&gt;<span class="built_in">GetPageId</span>(), key, new_node-&gt;<span class="built_in">GetPageId</span>());</span><br><span class="line">    <span class="comment">// 修改old_node和new_node的父指针</span></span><br><span class="line">    old_node-&gt;<span class="built_in">SetParentPageId</span>(new_page_id);</span><br><span class="line">    new_node-&gt;<span class="built_in">SetParentPageId</span>(new_page_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// buffer_pool_manager_-&gt;UnpinPage(new_node-&gt;GetPageId(), true);  // DEBUG  </span></span><br><span class="line">    buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(new_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>);  <span class="comment">// 修改了new_page-&gt;data，所以dirty置为true</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">UpdateRootPageId</span>(<span class="number">0</span>);  <span class="comment">// update root page id in header page</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的root必定不在transaction的page_set_队列中</span></span><br><span class="line">    <span class="keyword">if</span> (*root_is_latched) &#123;</span><br><span class="line">      *root_is_latched = <span class="literal">false</span>;</span><br><span class="line">      root_latch_.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UnlockPages</span>(transaction);</span><br><span class="line">    <span class="comment">// LOG_INFO(&quot;InsertIntoParent old node is root: completed key=%ld thread=%lu&quot;, key.ToString(), getThreadId());</span></span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">// 结束递归</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// LOG_INFO(&quot;InsertIntoParent old node is NOT root: completed key=%ld thread=%lu&quot;, key.ToString(), getThreadId());</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2 old_node不是根结点</span></span><br><span class="line">  <span class="comment">// 找到old_node的父结点进行操作</span></span><br><span class="line">  <span class="comment">// a. 先直接插入(key,new_node-&gt;page_id)到父结点</span></span><br><span class="line">  <span class="comment">// b. 如果插入后父结点满了，则需要对父结点再进行拆分(Split)，并继续递归</span></span><br><span class="line">  <span class="comment">// buffer_pool_manager_-&gt;UnpinPage(new_node-&gt;GetPageId(), true);                      // DEBUG</span></span><br><span class="line">  Page *parent_page = buffer_pool_manager_-&gt;<span class="built_in">FetchPage</span>(old_node-&gt;<span class="built_in">GetParentPageId</span>());  <span class="comment">// pin parent page</span></span><br><span class="line"></span><br><span class="line">  InternalPage *parent_node = <span class="built_in">reinterpret_cast</span>&lt;InternalPage *&gt;(parent_page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">  <span class="comment">// 将(key,new_node-&gt;page_id)插入到父结点中 value==old_node-&gt;page_id 的下标之后</span></span><br><span class="line">  parent_node-&gt;<span class="built_in">InsertNodeAfter</span>(old_node-&gt;<span class="built_in">GetPageId</span>(), key, new_node-&gt;<span class="built_in">GetPageId</span>());  <span class="comment">// size+1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 父节点未满</span></span><br><span class="line">  <span class="keyword">if</span> (parent_node-&gt;<span class="built_in">GetSize</span>() &lt; parent_node-&gt;<span class="built_in">GetMaxSize</span>()) &#123;</span><br><span class="line">    <span class="comment">// DEBUG</span></span><br><span class="line">    <span class="keyword">if</span> (*root_is_latched) &#123;</span><br><span class="line">      *root_is_latched = <span class="literal">false</span>;</span><br><span class="line">      root_latch_.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UnlockPages</span>(transaction);  <span class="comment">// unlock除了叶子结点以外的所有上锁的祖先节点</span></span><br><span class="line">    buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(parent_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>);  <span class="comment">// unpin parent page</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 父结点已满(注意，之前的insert使得size+1)，需要拆分，再递归InsertIntoParent</span></span><br><span class="line">  <span class="comment">// parent_node拆分成两个，分别是parent_node和new_parent_node</span></span><br><span class="line">  InternalPage *new_parent_node = <span class="built_in">Split</span>(parent_node);  <span class="comment">// pin new parent node</span></span><br><span class="line">  <span class="comment">// 继续递归，下一层递归是将拆分后新结点new_parent_node的第一个key插入到parent_node的父结点</span></span><br><span class="line">  <span class="built_in">InsertIntoParent</span>(parent_node, new_parent_node-&gt;<span class="built_in">KeyAt</span>(<span class="number">0</span>), new_parent_node, transaction, root_is_latched);</span><br><span class="line"></span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(parent_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>);      <span class="comment">// unpin parent page</span></span><br><span class="line">  buffer_pool_manager_-&gt;<span class="built_in">UnpinPage</span>(new_parent_node-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>);  <span class="comment">// unpin new parent node</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><ul><li>本地测试</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ ./test/b_plus_tree_insert_test </span><br><span class="line">Running main() from gmock_main.cc</span><br><span class="line">[==========] Running 2 tests from 1 <span class="built_in">test</span> suite.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 2 tests from BPlusTreeTests</span><br><span class="line">[ RUN      ] BPlusTreeTests.InsertTest1</span><br><span class="line">[       OK ] BPlusTreeTests.InsertTest1 (1 ms)</span><br><span class="line">[ RUN      ] BPlusTreeTests.InsertTest2</span><br><span class="line">[       OK ] BPlusTreeTests.InsertTest2 (0 ms)</span><br><span class="line">[----------] 2 tests from BPlusTreeTests (1 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global <span class="built_in">test</span> environment tear-down</span><br><span class="line">[==========] 2 tests from 1 <span class="built_in">test</span> suite ran. (1 ms total)</span><br><span class="line">[  PASSED  ] 2 tests.</span><br></pre></td></tr></table></figure><ul><li>Gradescope测试</li></ul><img src="/2022/09/14/lab2-3/grade.jpg" class="">]]></content>
    
    
    <summary type="html">&lt;style&gt;
@import url(https://fonts.googleapis.com/css?family=Roboto);
blockquote {
 /* color:#888; */
 background-color: #f9f2f4;
 border-left: 0.2em solid #FA7298;
 padding: 1em 0.7em 1em 0.7em;
 position: relative;
 /* font-family: &#39;Roboto&#39;, sans-serif; */
 line-height: 150%;
 border-radius: 3px;
 /* text-indent: 35px; */
}
&lt;/style&gt;

&lt;h2 id=&quot;Task-2-A-B-TREE-DATA-STRUCTURE-INSERTION-amp-POINT-SEARCH&quot;&gt;&lt;a href=&quot;#Task-2-A-B-TREE-DATA-STRUCTURE-INSERTION-amp-POINT-SEARCH&quot; class=&quot;headerlink&quot; title=&quot;Task 2.A - B+TREE DATA STRUCTURE (INSERTION &amp;amp; POINT SEARCH)&quot;&gt;&lt;/a&gt;Task 2.A - B+TREE DATA STRUCTURE (INSERTION &amp;amp; POINT SEARCH)&lt;/h2&gt;&lt;blockquote&gt;
实现b_plus_tree.cpp/InsertIntoLeaf函数所涉及到的相关函数。
&lt;/blockquote&gt;

&lt;p&gt;您的B +树索引只能支持唯一键。 也就是说，当您尝试将具有重复键的键值对插入索引时，它应该返回false&lt;/p&gt;
&lt;p&gt;对于checkpoint1，仅需要B + Tree索引支持插入（&lt;code&gt;Insert&lt;/code&gt;）和点搜索（&lt;code&gt;GetValue&lt;/code&gt;）。 您不需要实现删除操作。 插入后如果当前键&amp;#x2F;值对的数量等于&lt;code&gt;max_size&lt;/code&gt;，则应该正确执行分割。 由于任何写操作都可能导致B + Tree索引中的&lt;code&gt;root_page_id&lt;/code&gt;发生更改，因此您有责任更新（src &amp;#x2F; include &amp;#x2F; storage &amp;#x2F; page &amp;#x2F; header_page.h）中的&lt;code&gt;root_page_id&lt;/code&gt;，以确保索引在磁盘上具有持久性 。 在&lt;code&gt;BPlusTree&lt;/code&gt;类中，我们已经为您实现了一个名为&lt;code&gt;UpdateRootPageId&lt;/code&gt;的函数。 您需要做的就是在B + Tree索引的&lt;code&gt;root_page_id&lt;/code&gt;更改时调用此函数。&lt;/p&gt;
&lt;p&gt;您的B + Tree实现必须隐藏key&amp;#x2F;value等的详细信息，建议使用如下结构：&lt;/p&gt;</summary>
    
    
    
    <category term="CMU15-445" scheme="http://zyyyyy.com/categories/CMU15-445/"/>
    
    
    <category term="数据库存储" scheme="http://zyyyyy.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/"/>
    
    <category term="B+ Tree" scheme="http://zyyyyy.com/tags/B-Tree/"/>
    
  </entry>
  
  <entry>
    <title>CMU15-445 lab02(Part 2)</title>
    <link href="http://zyyyyy.com/2022/09/06/lab2-2/"/>
    <id>http://zyyyyy.com/2022/09/06/lab2-2/</id>
    <published>2022-09-06T09:45:13.000Z</published>
    <updated>2022-09-16T16:07:09.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="B-TREE-LEAF-PAGE"><a href="#B-TREE-LEAF-PAGE" class="headerlink" title="B+TREE LEAF PAGE"></a>B+TREE LEAF PAGE</h2><p>Leaf Page存储一个有序的m键条目和m值条目。在你的实现中，值应该仅为64位的record_id，用于定位实际元组存储的位置，参见在src&#x2F;include&#x2F;common&#x2F;RID.h下定义的RID类。叶子页与内部页在键&#x2F;值对的数量上有相同的限制，并且应该遵循相同的合并、重分发和拆分操作。</p><p>必须在指定文件中实现内页。只允许修改头文件(src&#x2F;include&#x2F;storage&#x2F;page&#x2F;b_plus_tree_leaf_page.h)及其对应的源文件。</p><p>要点:即使叶子页和内部页包含相同类型的键，它们也可能有不同类型的值，因此叶子页和内部页的max_size可能不同。</p><span id="more"></span><h3 id="类基本函数"><a href="#类基本函数" class="headerlink" title="类基本函数"></a>类基本函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::Init</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">page_id_t</span> parent_id, <span class="type">int</span> max_size)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SetPageType</span>(IndexPageType::LEAF_PAGE);</span><br><span class="line">  <span class="built_in">SetPageId</span>(page_id);</span><br><span class="line">  <span class="built_in">SetParentPageId</span>(parent_id);</span><br><span class="line">  <span class="built_in">SetSize</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">SetMaxSize</span>(max_size);</span><br><span class="line">  <span class="built_in">SetNextPageId</span>(INVALID_PAGE_ID);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Helper methods to set/get next page id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">page_id_t</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::GetNextPageId</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> next_page_id_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::SetNextPageId</span><span class="params">(<span class="type">page_id_t</span> next_page_id)</span> </span>&#123; next_page_id_ = next_page_id; &#125;</span><br></pre></td></tr></table></figure><h3 id="KeyIndex-函数"><a href="#KeyIndex-函数" class="headerlink" title="KeyIndex()函数"></a>KeyIndex()函数</h3><ul><li>查找leaf page的array中第一个&gt;&#x3D;key的下标。</li><li>这里用y总的<font color=blue><a href="https://www.acwing.com/problem/content/791/">整数二分模板（左边界）</a></font>，且要注意key比array中所有key都要小的情况。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::KeyIndex</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> KeyComparator &amp;comparator)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> r = <span class="built_in">GetSize</span>() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comparator</span>(<span class="built_in">KeyAt</span>(mid), key) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      r = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">comparator</span>(<span class="built_in">KeyAt</span>(l), key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetSize</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Set-and-Get"><a href="#Set-and-Get" class="headerlink" title="Set and Get"></a>Set and Get</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function">KeyType <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::KeyAt</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// replace with your own code</span></span><br><span class="line">  <span class="keyword">return</span> array[index].first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Helper method to find and return the key &amp; value pair associated with input</span></span><br><span class="line"><span class="comment"> * &quot;index&quot;(a.k.a array offset)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">const</span> MappingType &amp;<span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::GetItem</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// replace with your own code</span></span><br><span class="line">  <span class="keyword">return</span> array[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Insert函数"><a href="#Insert函数" class="headerlink" title="Insert函数"></a>Insert函数</h3><ul><li>先查找第一个&gt;&#x3D;key的的下标。</li><li>判断是否重复。</li><li>不重复则数组下标&gt;&#x3D;insert_index的元素整体后移1位。</li><li>[insert_index, size - 1] –&gt; [insert_index + 1, size]</li><li>最后进行插入操作。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::Insert</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> ValueType &amp;value, <span class="type">const</span> KeyComparator &amp;comparator)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> insert_index = <span class="built_in">KeyIndex</span>(key, comparator);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">comparator</span>(<span class="built_in">KeyAt</span>(insert_index), key) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetSize</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">GetSize</span>(); i &gt; insert_index; i--) &#123;</span><br><span class="line">    array[i] = array[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  array[insert_index] = MappingType&#123;key, value&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">IncreaseSize</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">GetSize</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MoveHalfTo函数"><a href="#MoveHalfTo函数" class="headerlink" title="MoveHalfTo函数"></a>MoveHalfTo函数</h3><ul><li><code>MoveHalfTo()</code>将this page的从array+start_index开始的move_num个元素复制到recipient page的array尾部。</li><li><code>CopyNFrom()</code>[items,items+size)复制到该page的array最后一个之后的空间。</li><li>注意叶子结点的操作较为简单，无需更新子节点的父指针。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Remove half of key &amp; value pairs from this page to &quot;recipient&quot; page</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::MoveHalfTo</span><span class="params">(BPlusTreeLeafPage *recipient)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> start_index = <span class="built_in">GetMinSize</span>();</span><br><span class="line">  <span class="type">int</span> move_num = <span class="built_in">GetSize</span>() - start_index;</span><br><span class="line">  recipient-&gt;<span class="built_in">CopyNFrom</span>(array + start_index, move_num);</span><br><span class="line">  <span class="built_in">IncreaseSize</span>(-move_num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copy starting from items, and copy &#123;size&#125; number of elements into me.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::CopyNFrom</span><span class="params">(MappingType *items, <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">  std::<span class="built_in">copy</span>(items, items + size, array + <span class="built_in">GetSize</span>());</span><br><span class="line">  <span class="built_in">IncreaseSize</span>(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lookup函数"><a href="#Lookup函数" class="headerlink" title="Lookup函数"></a>Lookup函数</h3><ul><li>得到leaf page中key对应的value（传出参数），返回key是否在leaf page中存在。</li><li>首先用<code>KeyIndex()</code>查找第一个&gt;&#x3D;key的的下标。</li><li>若<code>=key</code>的下标不存在（只有&gt;key的下标），返回<code>false</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::Lookup</span><span class="params">(<span class="type">const</span> KeyType &amp;key, ValueType *value, <span class="type">const</span> KeyComparator &amp;comparator)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> target_index = <span class="built_in">KeyIndex</span>(key, comparator);                                  <span class="comment">// 查找第一个&gt;=key的的下标</span></span><br><span class="line">  <span class="keyword">if</span> (target_index == <span class="built_in">GetSize</span>() || <span class="built_in">comparator</span>(key, <span class="built_in">KeyAt</span>(target_index)) != <span class="number">0</span>) &#123;  <span class="comment">// =key的下标不存在（只有&gt;key的下标）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *value = array[target_index].second;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h3 id="RemoveAndDeleteRecord函数"><a href="#RemoveAndDeleteRecord函数" class="headerlink" title="RemoveAndDeleteRecord函数"></a>RemoveAndDeleteRecord函数</h3><ul><li>首先用<code>KeyIndex()</code>查找第一个&gt;&#x3D;key的的下标。</li><li>若<code>=key</code>的下标不存在（只有&gt;key的下标），返回<code>Getsize()</code>。</li><li>将<code>target_index</code>后的子数组往前移动一位，覆盖当前值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::RemoveAndDeleteRecord</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> KeyComparator &amp;comparator)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> target_index = <span class="built_in">KeyIndex</span>(key, comparator);                                  <span class="comment">// 查找第一个&gt;=key的的下标</span></span><br><span class="line">  <span class="keyword">if</span> (target_index == <span class="built_in">GetSize</span>() || <span class="built_in">comparator</span>(key, <span class="built_in">KeyAt</span>(target_index)) != <span class="number">0</span>) &#123;  <span class="comment">// =key的下标不存在（只有&gt;key的下标）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetSize</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">IncreaseSize</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = target_index; i &lt; <span class="built_in">GetSize</span>(); i++) &#123;</span><br><span class="line">    array[i] = array[i + <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">GetSize</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他函数操作"><a href="#其他函数操作" class="headerlink" title="其他函数操作"></a>其他函数操作</h3><ul><li>内部节点的思路大同小异，就不过多赘述了（注意叶子节点无需更新子节点的父指针）。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment"> * MERGE</span></span><br><span class="line"><span class="comment"> *****************************************************************************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Remove all of key &amp; value pairs from this page to &quot;recipient&quot; page. Don&#x27;t forget</span></span><br><span class="line"><span class="comment"> * to update the next_page id in the sibling page</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::MoveAllTo</span><span class="params">(BPlusTreeLeafPage *recipient)</span> </span>&#123;</span><br><span class="line">  recipient-&gt;<span class="built_in">CopyNFrom</span>(array, <span class="built_in">GetSize</span>());</span><br><span class="line">  <span class="built_in">SetSize</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************************************</span></span><br><span class="line"><span class="comment"> * REDISTRIBUTE</span></span><br><span class="line"><span class="comment"> *****************************************************************************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Remove the first key &amp; value pair from this page to &quot;recipient&quot; page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::MoveFirstToEndOf</span><span class="params">(BPlusTreeLeafPage *recipient)</span> </span>&#123;</span><br><span class="line">  recipient-&gt;<span class="built_in">CopyLastFrom</span>(array[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">IncreaseSize</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">GetSize</span>(); i++) &#123;</span><br><span class="line">    array[i] = array[i + <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copy the item into the end of my item list. (Append item to my array)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::CopyLastFrom</span><span class="params">(<span class="type">const</span> MappingType &amp;item)</span> </span>&#123;</span><br><span class="line">  array[<span class="built_in">GetSize</span>()] = item;</span><br><span class="line">  <span class="built_in">IncreaseSize</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Remove the last key &amp; value pair from this page to &quot;recipient&quot; page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::MoveLastToFrontOf</span><span class="params">(BPlusTreeLeafPage *recipient)</span> </span>&#123;</span><br><span class="line">  recipient-&gt;<span class="built_in">CopyFirstFrom</span>(array[<span class="built_in">GetSize</span>() - <span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">IncreaseSize</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Insert item at the front of my items. Move items accordingly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::CopyFirstFrom</span><span class="params">(<span class="type">const</span> MappingType &amp;item)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">GetSize</span>(); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    array[i + <span class="number">1</span>] = array[i];</span><br><span class="line">  &#125;</span><br><span class="line">  array[<span class="number">0</span>] = item;</span><br><span class="line">  <span class="built_in">IncreaseSize</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;B-TREE-LEAF-PAGE&quot;&gt;&lt;a href=&quot;#B-TREE-LEAF-PAGE&quot; class=&quot;headerlink&quot; title=&quot;B+TREE LEAF PAGE&quot;&gt;&lt;/a&gt;B+TREE LEAF PAGE&lt;/h2&gt;&lt;p&gt;Leaf Page存储一个有序的m键条目和m值条目。在你的实现中，值应该仅为64位的record_id，用于定位实际元组存储的位置，参见在src&amp;#x2F;include&amp;#x2F;common&amp;#x2F;RID.h下定义的RID类。叶子页与内部页在键&amp;#x2F;值对的数量上有相同的限制，并且应该遵循相同的合并、重分发和拆分操作。&lt;/p&gt;
&lt;p&gt;必须在指定文件中实现内页。只允许修改头文件(src&amp;#x2F;include&amp;#x2F;storage&amp;#x2F;page&amp;#x2F;b_plus_tree_leaf_page.h)及其对应的源文件。&lt;/p&gt;
&lt;p&gt;要点:即使叶子页和内部页包含相同类型的键，它们也可能有不同类型的值，因此叶子页和内部页的max_size可能不同。&lt;/p&gt;</summary>
    
    
    
    <category term="CMU15-445" scheme="http://zyyyyy.com/categories/CMU15-445/"/>
    
    
    <category term="数据库存储" scheme="http://zyyyyy.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/"/>
    
    <category term="B+ Tree" scheme="http://zyyyyy.com/tags/B-Tree/"/>
    
  </entry>
  
  <entry>
    <title>CMU15-445 lab02(Part 1)</title>
    <link href="http://zyyyyy.com/2022/09/02/lab2/"/>
    <id>http://zyyyyy.com/2022/09/02/lab2/</id>
    <published>2022-09-02T12:38:58.000Z</published>
    <updated>2022-09-16T16:07:13.372Z</updated>
    
    <content type="html"><![CDATA[<!-- <style>.table-wrapper {    display: block;    overflow-x: auto;}</style> --><h1 id="Task1-B-TREE-PAGES"><a href="#Task1-B-TREE-PAGES" class="headerlink" title="Task1 - B+TREE PAGES"></a>Task1 - B+TREE PAGES</h1><p>您需要实现三个页面类来存储B+树的数据。</p><ul><li>B+Tree Parent Page</li><li>B+Tree Internal Page</li><li>B+Tree Leaf Page</li></ul><span id="more"></span><h2 id="B-Tree-Parent-Page"><a href="#B-Tree-Parent-Page" class="headerlink" title="B+ Tree Parent Page"></a>B+ Tree Parent Page</h2><p>这是内部页和叶页都继承的父类，它只包含两个子类共享的信息。父页面被划分为如下表所示的几个字段。</p><ul><li>B+Tree Parent Page Content</li></ul><div class="table-wrapper"><table><thead><tr><th>Variable Name</th><th>Size</th><th>Description</th></tr></thead><tbody><tr><td>page_type_</td><td>4</td><td>Page Type (internal or leaf)</td></tr><tr><td>lsn_</td><td>4</td><td>Log sequence number (Used in Project 4)</td></tr><tr><td>size_</td><td>4</td><td>Number of Key &amp; Value pairs in page</td></tr><tr><td>max_size_</td><td>4</td><td>Max number of Key &amp; Value pairs in page</td></tr><tr><td>parent_page_id_</td><td>4</td><td>Parent Page Id</td></tr><tr><td>page_id_</td><td>4</td><td>Self Page Id</td></tr></tbody></table></div>你必须在指定文件中实现父页。你只允许修改头文件(src/include/storage/page/b_plus_tree_page.h)和它对应的源文件(src/page/b_plus_tree_page.cpp)。<ul><li>这里属于白给送分题，把各种set和get函数填空就行。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> bustub &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Helper methods to get/set page type</span></span><br><span class="line"><span class="comment"> * Page type enum class is defined in b_plus_tree_page.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BPlusTreePage::IsLeafPage</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> page_type_ == IndexPageType::LEAF_PAGE; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BPlusTreePage::IsRootPage</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> parent_page_id_ == INVALID_PAGE_ID; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPlusTreePage::SetPageType</span><span class="params">(IndexPageType page_type)</span> </span>&#123; page_type_ = page_type; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Helper methods to get/set size (number of key/value pairs stored in that</span></span><br><span class="line"><span class="comment"> * page)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BPlusTreePage::GetSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPlusTreePage::SetSize</span><span class="params">(<span class="type">int</span> size)</span> </span>&#123; size_ = size; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPlusTreePage::IncreaseSize</span><span class="params">(<span class="type">int</span> amount)</span> </span>&#123; size_ += amount; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Helper methods to get/set max size (capacity) of the page</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BPlusTreePage::GetMaxSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> max_size_; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPlusTreePage::SetMaxSize</span><span class="params">(<span class="type">int</span> size)</span> </span>&#123; max_size_ = size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Helper method to get min page size</span></span><br><span class="line"><span class="comment"> * Generally, min page size == max page size / 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BPlusTreePage::GetMinSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> max_size_ / <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Helper methods to get/set parent page id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">page_id_t</span> <span class="title">BPlusTreePage::GetParentPageId</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> parent_page_id_; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPlusTreePage::SetParentPageId</span><span class="params">(<span class="type">page_id_t</span> parent_page_id)</span> </span>&#123; parent_page_id_ = parent_page_id; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Helper methods to get/set self page id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">page_id_t</span> <span class="title">BPlusTreePage::GetPageId</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> page_id_; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPlusTreePage::SetPageId</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123; page_id_ = page_id; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Helper methods to set lsn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPlusTreePage::SetLSN</span><span class="params">(<span class="type">lsn_t</span> lsn)</span> </span>&#123; lsn_ = lsn; &#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace bustub</span></span><br></pre></td></tr></table></figure><h2 id="B-TREE-INTERNAL-PAGE"><a href="#B-TREE-INTERNAL-PAGE" class="headerlink" title="B+TREE INTERNAL PAGE"></a>B+TREE INTERNAL PAGE</h2><p>内部页不存储任何实际数据，而是存储有序的m个键条目和m + 1个指针（也称为page_id）。 由于指针的数量不等于键的数量，因此将第一个键设置为无效，并且查找方法应始终从第二个键开始。 任何时候，每个内部页面至少有一半已满。 在删除期间，可以将两个半满页面合并为合法页面，或者可以将其重新分配以避免合并，而在插入期间，可以将一个完整页面分为两部分。</p><p>你只能修改头文件(src&#x2F;include&#x2F;storage&#x2F;page&#x2F;b_plus_tree_internal_page.h) 和对应的源文件(src&#x2F;page&#x2F;b_plus_tree_internal_page.cpp).</p><ul><li>如图所示，第一个node被设置为无效, 没有key值。</li></ul><img src="/2022/09/02/lab2/t1.jpg" class=""><h3 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::Init</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">page_id_t</span> parent_id, <span class="type">int</span> max_size)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SetPageType</span>(IndexPageType::INTERNAL_PAGE);</span><br><span class="line">  <span class="built_in">SetPageId</span>(page_id);</span><br><span class="line">  <span class="built_in">SetParentPageId</span>(parent_id);</span><br><span class="line">  <span class="built_in">SetSize</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">SetMaxSize</span>(max_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本的数组内部函数"><a href="#基本的数组内部函数" class="headerlink" title="基本的数组内部函数"></a>基本的数组内部函数</h3><ul><li><code>array</code>表示中间节点的内部数组。</li><li><code>first</code>存key，也就是主键。</li><li><code>second</code>存value，即指向子节点的指针。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function">KeyType <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::KeyAt</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array[index].first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::SetKeyAt</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> KeyType &amp;key)</span> </span>&#123; array[index].first = key; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::ValueIndex</span><span class="params">(<span class="type">const</span> ValueType &amp;value)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">GetSize</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i].second == value) &#123;</span><br><span class="line">      <span class="keyword">return</span> i; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function">ValueType <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::ValueAt</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> array[index].second; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function">KeyType <span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::KeyAt</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array[index].first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Helper method to find and return the key &amp; value pair associated with input</span></span><br><span class="line"><span class="comment"> * &quot;index&quot;(a.k.a array offset)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">const</span> MappingType &amp;<span class="title">B_PLUS_TREE_LEAF_PAGE_TYPE::GetItem</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lookup函数（内部节点）"><a href="#Lookup函数（内部节点）" class="headerlink" title="Lookup函数（内部节点）"></a>Lookup函数（内部节点）</h3><ul><li>这里是让我们查找并返回指向子页面的子指针(page_id)，该页面包含输入“key”。</li><li>从第二个键开始搜索(第一个键是无效的)</li><li>注意到<code>K(i) &lt;= K &lt; K(i+1)</code>，只需查找小于等于input的最后一个key即可。</li><li>这里用y总的<font color=blue><a href="https://www.acwing.com/problem/content/791/">整数二分模板（右边界）</a></font>，且要注意key比array中所有key都要小的情况。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function">ValueType <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::Lookup</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> KeyComparator &amp;comparator)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> r = <span class="built_in">GetSize</span>() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comparator</span>(<span class="built_in">KeyAt</span>(mid), key) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      l = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">comparator</span>(<span class="built_in">KeyAt</span>(l), key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> array[<span class="number">0</span>].second; <span class="comment">// Cannot find satisdied key. The key is smaller than any valid key.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ValueAt</span>(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入函数"><a href="#插入函数" class="headerlink" title="插入函数"></a>插入函数</h3><ul><li><code>PopulateNewRoot()</code>填充分裂后新的根节点，只在<code>InsertIntoParent()</code>(b_plus_tree.cpp)中调用。</li><li><code>InsertNodeAfter()</code>将<code>new_key</code>和<code>new_value</code>对插入到值为<code>old_value</code>的键值对之后。</li><li>先找到存有<code>old_value</code>的键值对，数组下标大于等于insert_index的元素整体后移1位，在空位插入新的node。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::PopulateNewRoot</span><span class="params">(<span class="type">const</span> ValueType &amp;old_value, <span class="type">const</span> KeyType &amp;new_key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     <span class="type">const</span> ValueType &amp;new_value)</span> </span>&#123;</span><br><span class="line">  array[<span class="number">0</span>].second = old_value;</span><br><span class="line">  array[<span class="number">1</span>].first = new_key;</span><br><span class="line">  array[<span class="number">1</span>].second = new_value;</span><br><span class="line">  <span class="built_in">SetSize</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::InsertNodeAfter</span><span class="params">(<span class="type">const</span> ValueType &amp;old_value, <span class="type">const</span> KeyType &amp; new_key, <span class="type">const</span> ValueType &amp;new_value)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> insert_index = <span class="built_in">ValueIndex</span>(old_value);</span><br><span class="line">  insert_index;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">GetSize</span>(); i &gt; insert_index; i--) &#123;</span><br><span class="line">    array[i] = array[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  array[insert_index] = MappingType&#123;new_key, new_value&#125;;</span><br><span class="line">  <span class="built_in">IncreaseSize</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">GetSize</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MoveHalfTo函数"><a href="#MoveHalfTo函数" class="headerlink" title="MoveHalfTo函数"></a>MoveHalfTo函数</h3><ul><li><code>MoveHalfTo()</code>将old_node的右半部分array复制给new_node。</li><li><code>CopyNFrom()</code>将[items,items+size)复制到当前page的array最后一个键值对之后的空间。</li><li>找到调用<code>CopyNFrom()</code>函数的page的array中每个value指向的孩子结点，其父指针更新为调用该函数的page id。</li><li>注意，<code>UnpinPage()</code>的dirty参数要置为true，因为修改了page-&gt;data转为node后的<code>ParentPageId</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::MoveHalfTo</span><span class="params">(BPlusTreeInternalPage *recipient, BufferPoolManager *buffer_pool_manager)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> start_index = <span class="built_in">GetMinSize</span>();</span><br><span class="line">  <span class="type">int</span> move_num = <span class="built_in">GetSize</span>() - start_index;</span><br><span class="line">  recipient-&gt;<span class="built_in">CopyNFrom</span>(array + start_index, move_num, buffer_pool_manager);</span><br><span class="line">  <span class="built_in">IncreaseSize</span>(-move_num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::CopyNFrom</span><span class="params">(MappingType *items, <span class="type">int</span> size, BufferPoolManager *buffer_pool_manager)</span> </span>&#123;</span><br><span class="line">  std::<span class="built_in">copy</span>(items, items + size, array + <span class="built_in">GetSize</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">GetSize</span>(); i &lt; <span class="built_in">GetSize</span>() + size; i++) &#123;</span><br><span class="line">    Page *child_page = buffer_pool_manager-&gt;<span class="built_in">FetchPage</span>(<span class="built_in">ValueAt</span>(i));</span><br><span class="line">    BPlusTreePage *child_node = <span class="built_in">reinterpret_cast</span>&lt;BPlusTreePage *&gt;(child_page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">    child_node-&gt;<span class="built_in">SetParentPageId</span>(<span class="built_in">GetPageId</span>());</span><br><span class="line">    buffer_pool_manager-&gt;<span class="built_in">UnpinPage</span>(child_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">IncreaseSize</span>(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Remove函数"><a href="#Remove函数" class="headerlink" title="Remove函数"></a>Remove函数</h3><ul><li><code>Remove(int index)</code>删除<code>array[index]</code>，并将array整体向前移动一位填补空缺。</li><li><code>RemoveAndReturnOnlyChild()</code>删除内部页面中唯一的键和值对，并返回值，只能在AdjustRoot()中调用这个方法(在b_plus_tree.cpp中)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::Remove</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">IncreaseSize</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = index; i &lt; <span class="built_in">GetSize</span>(); i++) &#123;</span><br><span class="line">    array[i] = array[i + <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Remove the only key &amp; value pair in internal page and return the value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> only call this method within AdjustRoot()(in b_plus_tree.cpp)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function">ValueType <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::RemoveAndReturnOnlyChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SetSize</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ValueAt</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MoveAllTo函数"><a href="#MoveAllTo函数" class="headerlink" title="MoveAllTo函数"></a>MoveAllTo函数</h3><ul><li>将所有键值对移动到<code>recipient</code>。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::MoveAllTo</span><span class="params">(BPlusTreeInternalPage *recipient, <span class="type">const</span> KeyType &amp;middle_key, BufferPoolManager *buffer_pool_manager)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SetKeyAt</span>(<span class="number">0</span>, middle_key);</span><br><span class="line">  recipient-&gt;<span class="built_in">CopyNFrom</span>(array, <span class="built_in">GetSize</span>(), buffer_pool_manager);</span><br><span class="line">  <span class="built_in">SetSize</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MoveFirstToEndOf函数"><a href="#MoveFirstToEndOf函数" class="headerlink" title="MoveFirstToEndOf函数"></a>MoveFirstToEndOf函数</h3><ul><li>将所有当前page的第一个键值对移动到<code>recipient</code>最后。</li><li><code>CopyLastFrom()</code>给array赋值，再修改其子节点的父指针。</li><li>由于<code>FetchPage()</code>时pin住了该页面，最后需unpin。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::MoveFirstToEndOf</span><span class="params">(BPlusTreeInternalPage *recipient, <span class="type">const</span> KeyType &amp;middle_key,BufferPoolManager *buffer_pool_manager)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SetKeyAt</span>(<span class="number">0</span>, middle_key);</span><br><span class="line">  recipient-&gt;<span class="built_in">CopyLastFrom</span>(array[<span class="number">0</span>], buffer_pool_manager);</span><br><span class="line">  <span class="built_in">Remove</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Append an entry at the end.</span></span><br><span class="line"><span class="comment"> * Since it is an internal page, the moved entry(page)&#x27;s parent needs to be updated.</span></span><br><span class="line"><span class="comment"> * So I need to &#x27;adopt&#x27; it by changing its parent page id, which needs to be persisted with BufferPoolManger</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::CopyLastFrom</span><span class="params">(<span class="type">const</span> MappingType &amp;item, BufferPoolManager *buffer_pool_manager)</span> </span>&#123;</span><br><span class="line">  array[<span class="built_in">GetSize</span>()] = item;</span><br><span class="line">  Page *child_page = buffer_pool_manager-&gt;<span class="built_in">FetchPage</span>(<span class="built_in">ValueAt</span>(<span class="built_in">GetSize</span>()));</span><br><span class="line">  BPlusTreePage *child_node = <span class="built_in">reinterpret_cast</span>&lt;BPlusTreePage *&gt;(child_page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">  child_node-&gt;<span class="built_in">SetParentPageId</span>(<span class="built_in">GetPageId</span>());</span><br><span class="line">  buffer_pool_manager-&gt;<span class="built_in">UnpinPage</span>(child_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">IncreaseSize</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MoveLastToFrontOf函数"><a href="#MoveLastToFrontOf函数" class="headerlink" title="MoveLastToFrontOf函数"></a>MoveLastToFrontOf函数</h3><ul><li>将所有当前page的最后个键值对移动到<code>recipient</code>头部。</li><li>注意需将<code>recipient</code>整体后移一格。</li><li>由于<code>FetchPage()</code>时pin住了该页面，最后需unpin。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::MoveLastToFrontOf</span><span class="params">(BPlusTreeInternalPage *recipient, <span class="type">const</span> KeyType &amp;middle_key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       BufferPoolManager *buffer_pool_manager)</span> </span>&#123;</span><br><span class="line">  recipient-&gt;<span class="built_in">SetKeyAt</span>(<span class="number">0</span>, middle_key);</span><br><span class="line">  recipient-&gt;<span class="built_in">CopyFirstFrom</span>(array[<span class="built_in">GetSize</span>() - <span class="number">1</span>], buffer_pool_manager);</span><br><span class="line">  <span class="built_in">IncreaseSize</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Append an entry at the beginning.</span></span><br><span class="line"><span class="comment"> * Since it is an internal page, the moved entry(page)&#x27;s parent needs to be updated.</span></span><br><span class="line"><span class="comment"> * So I need to &#x27;adopt&#x27; it by changing its parent page id, which needs to be persisted with BufferPoolManger</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::CopyFirstFrom</span><span class="params">(<span class="type">const</span> MappingType &amp;item, BufferPoolManager *buffer_pool_manager)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">GetSize</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    array[i + <span class="number">1</span>] = array[i];</span><br><span class="line">  &#125;</span><br><span class="line">  array[<span class="number">0</span>] = item;</span><br><span class="line">  Page *child_page = buffer_pool_manager-&gt;<span class="built_in">FetchPage</span>(<span class="built_in">ValueAt</span>(<span class="number">0</span>));</span><br><span class="line">  BPlusTreePage *child_node = <span class="built_in">reinterpret_cast</span>&lt;BPlusTreePage *&gt;(child_page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">  child_node-&gt;<span class="built_in">SetParentPageId</span>(<span class="built_in">GetPageId</span>());</span><br><span class="line">  buffer_pool_manager-&gt;<span class="built_in">UnpinPage</span>(child_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>);</span><br><span class="line">  <span class="built_in">IncreaseSize</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;!-- &lt;style&gt;
.table-wrapper {
    display: block;
    overflow-x: auto;
}
&lt;/style&gt; --&gt;
&lt;h1 id=&quot;Task1-B-TREE-PAGES&quot;&gt;&lt;a href=&quot;#Task1-B-TREE-PAGES&quot; class=&quot;headerlink&quot; title=&quot;Task1 - B+TREE PAGES&quot;&gt;&lt;/a&gt;Task1 - B+TREE PAGES&lt;/h1&gt;&lt;p&gt;您需要实现三个页面类来存储B+树的数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B+Tree Parent Page&lt;/li&gt;
&lt;li&gt;B+Tree Internal Page&lt;/li&gt;
&lt;li&gt;B+Tree Leaf Page&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="CMU15-445" scheme="http://zyyyyy.com/categories/CMU15-445/"/>
    
    
    <category term="数据库存储" scheme="http://zyyyyy.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/"/>
    
    <category term="B+ Tree" scheme="http://zyyyyy.com/tags/B-Tree/"/>
    
  </entry>
  
  <entry>
    <title>CMU15-445 lab01</title>
    <link href="http://zyyyyy.com/2022/08/29/lab1/"/>
    <id>http://zyyyyy.com/2022/08/29/lab1/</id>
    <published>2022-08-29T07:17:19.000Z</published>
    <updated>2022-09-16T16:07:26.202Z</updated>
    
    <content type="html"><![CDATA[<style>@import url(https://fonts.googleapis.com/css?family=Roboto);blockquote { /* color:#888; */ background-color: #f9f2f4; border-left: 0.2em solid #FA7298; padding: 1em 0.7em 1em 0.7em; position: relative; /* font-family: 'Roboto', sans-serif; */ line-height: 150%; border-radius: 3px; /* text-indent: 35px; */}</style><h1 id="Task1-LRU-REPLACEMENT-POLICY"><a href="#Task1-LRU-REPLACEMENT-POLICY" class="headerlink" title="Task1 LRU REPLACEMENT POLICY"></a>Task1 LRU REPLACEMENT POLICY</h1><h2 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h2><p>这个任务要求我们实现在课堂上所描述的LRU算法。</p><p>你需要实现下面这些函数。请确保他们都是线程安全的。</p><ul><li><p><code>Victim(T*)</code> :  Remove the object that was accessed the least recently compared to all the elements being tracked by the Replacer, store its contents in the output parameter and return True. If the Replacer is empty return False.</p></li><li><p><code>Pin(T)</code> :This method should be called after a page is pinned to a frame in the BufferPoolManager. It should remove the frame containing the pinned page from the LRUReplacer.</p></li><li><p><code>Unpin(T)</code> : This method should be called when the pin_count of a page becomes 0. This method should add the frame containing the unpinned page to the LRUReplacer.</p></li><li><p><code>Size()</code> : This method returns the number of frames that are currently in the LRUReplacer.</p></li></ul><span id="more"></span><h2 id="LRU实现"><a href="#LRU实现" class="headerlink" title="LRU实现"></a>LRU实现</h2><h3 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h3><blockquote>LRU 算法的设计原则是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。</blockquote><ul><li>考虑到线程安全及并发错误， 需要在函数中加入<code>latch</code>锁。</li><li><code>capacity</code>表示replacer的容量。</li><li><code>lru_list</code>为双向链表，记录replacer的frame。</li><li>使用<code>lruMap</code>哈希表+双链表的结构，哈希表存储frame id以及指向<code>lru_list</code>内frame的begin指针，让插入和删除复杂度均为O(1)。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::mutex latch;  <span class="comment">// thread safety</span></span><br><span class="line">  <span class="type">size_t</span> capacity;   <span class="comment">// max number of pages LRUReplacer can handle</span></span><br><span class="line">  std::list&lt;<span class="type">frame_id_t</span>&gt; lru_list;</span><br><span class="line">  std::unordered_map&lt;<span class="type">frame_id_t</span>, std::list&lt;<span class="type">frame_id_t</span>&gt;::iterator&gt; lruMap;</span><br></pre></td></tr></table></figure><h3 id="Victim-函数实现"><a href="#Victim-函数实现" class="headerlink" title="Victim 函数实现"></a>Victim 函数实现</h3><blockquote>注意这里必须要加锁，以防止并发错误。</blockquote><ul><li>使用<code>std::scoped_lock</code>c++17中的scope锁，它能够避免死锁发生，其构造函数能够自动进行上锁操作，析构函数会对互斥量进行解锁操作，保证线程安全。</li><li>如果replacer为空，意味着找不到牺牲页，返回<code>false</code>。</li><li>如果replacer非空，删除最久未使用的页面。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LRUReplacer::Victim</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> </span>&#123;</span><br><span class="line">  std::scoped_lock lock&#123;latch&#125;;</span><br><span class="line">  <span class="comment">// If empty, it means that no victim can be found.</span></span><br><span class="line">  <span class="keyword">if</span> (lruMap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Find the last frame and remove it.</span></span><br><span class="line">  *frame_id = lru_list.<span class="built_in">back</span>();</span><br><span class="line">  lruMap.<span class="built_in">erase</span>(*frame_id);</span><br><span class="line">  lru_list.<span class="built_in">pop_back</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pin-函数实现"><a href="#pin-函数实现" class="headerlink" title="pin 函数实现"></a>pin 函数实现</h3><blockquote>注意这里必须要加锁，以防止并发错误。</blockquote><ul><li>pin的作用是标记该页（如正在使用），防止并发错误。</li><li>如果找到该frame, 将其从replacer中删除。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUReplacer::Pin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  std::scoped_lock lock&#123;latch&#125;;</span><br><span class="line">  <span class="comment">// Find the frame and pin it.</span></span><br><span class="line">  <span class="keyword">auto</span> it = lruMap.<span class="built_in">find</span>(frame_id);</span><br><span class="line">  <span class="keyword">if</span> (it != lruMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    lru_list.<span class="built_in">erase</span>(lruMap[frame_id]);</span><br><span class="line">    lruMap.<span class="built_in">erase</span>(frame_id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unpin-函数实现"><a href="#unpin-函数实现" class="headerlink" title="unpin 函数实现"></a>unpin 函数实现</h3><blockquote>注意这里必须要加锁，以防止并发错误。</blockquote><ul><li>unpin的作用是取消标记，将该页加入replacer中。</li><li>如果在replacer中找不到该frame，且replacer不满，加入该frame。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUReplacer::Unpin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  std::scoped_lock lock&#123;latch&#125;;</span><br><span class="line">  <span class="comment">// If exist, do nothing.</span></span><br><span class="line">  <span class="keyword">auto</span> it = lruMap.<span class="built_in">find</span>(frame_id);</span><br><span class="line">  <span class="keyword">if</span> (it != lruMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if list size &gt;= capacity, do nothing</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Size</span>() &gt;= capacity) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// insert</span></span><br><span class="line">  lru_list.<span class="built_in">push_front</span>(frame_id);</span><br><span class="line">  lruMap.<span class="built_in">emplace</span>(frame_id, lru_list.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><ul><li><strong>检测语法及格式</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ make format</span><br><span class="line">$ make check-lint</span><br><span class="line">$ make check-clang-tidy</span><br><span class="line">$ make lru_replacer_test</span><br></pre></td></tr></table></figure><ul><li><strong>测试</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ./test/lru_replacer_test</span><br><span class="line">Running main() from gmock_main.cc</span><br><span class="line">[==========] Running 1 <span class="built_in">test</span> from 1 <span class="built_in">test</span> suite.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 1 <span class="built_in">test</span> from LRUReplacerTest</span><br><span class="line">[ RUN      ] LRUReplacerTest.SampleTest</span><br><span class="line">[       OK ] LRUReplacerTest.SampleTest (0 ms)</span><br><span class="line">[----------] 1 <span class="built_in">test</span> from LRUReplacerTest (0 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global <span class="built_in">test</span> environment tear-down</span><br><span class="line">[==========] 1 <span class="built_in">test</span> from 1 <span class="built_in">test</span> suite ran. (0 ms total)</span><br><span class="line">[  PASSED  ] 1 <span class="built_in">test</span>.</span><br></pre></td></tr></table></figure><h1 id="Task2-BUFFER-POOL-MANAGER"><a href="#Task2-BUFFER-POOL-MANAGER" class="headerlink" title="Task2 BUFFER POOL MANAGER"></a>Task2 BUFFER POOL MANAGER</h1><h2 id="任务描述-1"><a href="#任务描述-1" class="headerlink" title="任务描述"></a>任务描述</h2><p>接下来，您需要在系统中实现缓冲池管理器<code>(BufferPoolManager)</code>。<code>BufferPoolManager</code>负责从<code>DiskManager</code>获取数据库页面并将它们存储在内存中。<code>BufferPoolManage</code>还可以在有要求它这样做时，或者当它需要驱逐一个页以便为新页腾出空间时，将脏页写入磁盘。为了确保您的实现能够正确地与系统的其余部分一起工作，我们将为您提供一些已经填写好的功能。您也不需要实现实际读写数据到磁盘的代码(在我们的实现中称为<code>DiskManager</code>)。我们将为您提供这一功能。</p><p>系统中的所有内存页面均由<code>Page</code>对象表示。<code>BufferPoolManager</code>不需要了解这些页面的内容。 但是，作为系统开发人员，重要的是要了解Page对象只是缓冲池中用于存储内存的容器，因此并不特定于唯一页面。 也就是说，每个<code>Page</code>对象都包含一块内存，<code>DiskManager</code>会将其用作复制从磁盘读取的物理页面内容的位置。 <code>BufferPoolManager</code>将在将其来回移动到磁盘时重用相同的<code>Page</code>对象来存储数据。 这意味着在系统的整个生命周期中，相同的<code>Page</code>对象可能包含不同的物理页面。<code>Page</code>对象的标识符（<code>page_id</code>）跟踪其包含的物理页面。 如果<code>Page</code>对象不包含物理页面，则必须将其<code>page_id</code>设置为<code>INVALID_PAGE_ID</code>。</p><p>每个<code>Page</code>对象还维护一个计数器，以显示“固定”该页面的线程数。<code>BufferPoolManager</code>不允许释放固定的页面。每个<code>Page</code>对象还跟踪它的脏标记。您的工作是判断页面在解绑定之前是否已经被修改（修改则把脏标记置为1）。<code>BufferPoolManager</code>必须将脏页的内容写回磁盘，然后才能重用该对象。</p><p><code>BufferPoolManager</code>实现将使用在此分配的前面步骤中创建的<code>LRUReplacer</code>类。它将使用<code>LRUReplacer</code>来跟踪何时访问页对象，以便在必须释放一个帧以为从磁盘复制新的物理页腾出空间时，它可以决定取消哪个页对象</p><p>你需要实现在(src&#x2F;buffer&#x2F;buffer_pool_manager.cpp):的以下函数</p><ul><li><code>FetchPageImpl(page_id)</code></li><li><code>NewPageImpl(page_id)</code></li><li><code>UnpinPageImpl(page_id, is_dirty)</code></li><li><code>FlushPageImpl(page_id)</code></li><li><code>DeletePageImpl(page_id)</code></li><li><code>FlushAllPagesImpl()</code></li></ul><h2 id="BufferPool实现"><a href="#BufferPool实现" class="headerlink" title="BufferPool实现"></a>BufferPool实现</h2><h3 id="基本数据结构-1"><a href="#基本数据结构-1" class="headerlink" title="基本数据结构"></a>基本数据结构</h3><ul><li><code>pool_size_</code>表示缓冲池的最大容量。</li><li><code>*pages_</code>指向缓冲池中page数组，用<code>pages_ = new Page[pool_size_]</code>来初始化。</li><li><code>page_table_</code>是页表，page_id标识磁盘页，页表记录了该page在磁盘中的page_id和对应缓冲池中的frame_id。</li><li><code>free_list</code>里面存的是frame_id，具体来说就是还没有被分配的缓冲池的数组项</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Number of pages in the buffer pool. */</span></span><br><span class="line"><span class="type">size_t</span> pool_size_;</span><br><span class="line"><span class="comment">/** Array of buffer pool pages. */</span></span><br><span class="line">Page *pages_;</span><br><span class="line"><span class="comment">/** Page table for keeping track of buffer pool pages. */</span></span><br><span class="line">std::unordered_map&lt;<span class="type">page_id_t</span>, <span class="type">frame_id_t</span>&gt; page_table_;</span><br><span class="line"><span class="comment">/** List of free pages. */</span></span><br><span class="line">std::list&lt;<span class="type">frame_id_t</span>&gt; free_list_;</span><br></pre></td></tr></table></figure><h3 id="UpdatePage函数实现"><a href="#UpdatePage函数实现" class="headerlink" title="UpdatePage函数实现"></a>UpdatePage函数实现</h3><ul><li>这是一个辅助函数，目的是更新页表中的数据。</li><li>如果是脏页，需要先将数据写回磁盘。</li><li>如果不是脏页，更新页表中的id。</li><li>最后清空该页，更新id。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferPoolManager::UpdatePage</span><span class="params">(Page *page, <span class="type">page_id_t</span> new_page_id, <span class="type">frame_id_t</span> new_frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (page-&gt;<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">    disk_manager_-&gt;<span class="built_in">WritePage</span>(page-&gt;page_id_, page-&gt;data_);</span><br><span class="line">    page-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Put the new page in page table.</span></span><br><span class="line">  page_table_.<span class="built_in">erase</span>(page-&gt;page_id_);</span><br><span class="line">  <span class="keyword">if</span> (new_page_id != INVALID_PAGE_ID) &#123;</span><br><span class="line">    page_table_.<span class="built_in">emplace</span>(new_page_id, new_frame_id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make the page data empty.</span></span><br><span class="line">  page-&gt;<span class="built_in">ResetMemory</span>();</span><br><span class="line">  page-&gt;page_id_ = new_page_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FindVictimPage函数实现"><a href="#FindVictimPage函数实现" class="headerlink" title="FindVictimPage函数实现"></a>FindVictimPage函数实现</h3><ul><li>这是一个辅助函数，目的是找到牺牲页。</li><li>如果<code>free_list_</code>不满，意味着buffer pool还有空位，找到<code>frame_id</code>。</li><li>如果缓冲池已满，调用LRU算法找牺牲页。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManager::FindVictimPage</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Buffer pool is not full. Get the frame id from free_list.</span></span><br><span class="line">  <span class="keyword">if</span> (!free_list_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    *frame_id = free_list_.<span class="built_in">front</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Buffer pool is full. Use LRU algorithm.</span></span><br><span class="line">  <span class="keyword">return</span> replacer_-&gt;<span class="built_in">Victim</span>(frame_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FetchPageImpl函数实现"><a href="#FetchPageImpl函数实现" class="headerlink" title="FetchPageImpl函数实现"></a>FetchPageImpl函数实现</h3><blockquote>注意这里必须要加锁，以防止并发错误。</blockquote><ul><li>如果能在<code>page_table_</code>页表中找到该页，调用<code>replacer</code>将其pin出。</li><li>如果找不到，说明该page不在缓冲池中，而在磁盘中，调用<code>FindVictimPage</code>在缓冲池中找到<code>frame</code>。</li><li>通过<code>frame_id</code>找到相应的<code>page</code>，更新数据，别忘了pin住该页。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Page *<span class="title">BufferPoolManager::FetchPageImpl</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.     Search the page table for the requested page (P).</span></span><br><span class="line">  <span class="comment">// 1.1    If P exists, pin it and return it immediately.</span></span><br><span class="line">  <span class="comment">// 1.2    If P does not exist, find a replacement page (R) from either the free list or the replacer.</span></span><br><span class="line">  <span class="comment">//        Note that pages are always found from the free list first.</span></span><br><span class="line">  <span class="comment">// 2.     If R is dirty, write it back to the disk.</span></span><br><span class="line">  <span class="comment">// 3.     Delete R from the page table and insert P.</span></span><br><span class="line">  <span class="comment">// 4.     Update P&#x27;s metadata, read in the page content from disk, and then return a pointer to P.</span></span><br><span class="line">  std::scoped_lock lock&#123;latch_&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> iter = page_table_.<span class="built_in">find</span>(page_id);</span><br><span class="line">  <span class="keyword">if</span> (iter != page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// Find the frame id through page table.</span></span><br><span class="line">    <span class="type">frame_id_t</span> frame_id = iter-&gt;second;</span><br><span class="line">    Page *page = &amp;pages_[frame_id];</span><br><span class="line">    <span class="comment">// Pin it and and record it in pin count.</span></span><br><span class="line">    replacer_-&gt;<span class="built_in">Pin</span>(frame_id);</span><br><span class="line">    page-&gt;pin_count_++;</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cannot find. It means that this page is in the disk.</span></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// Find the victim page and insert the disk page instead.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">FindVictimPage</span>(&amp;frame_id)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find the page and get the frame id.</span></span><br><span class="line">  Page *page = &amp;pages_[frame_id];</span><br><span class="line">  <span class="built_in">UpdatePage</span>(page, page_id, frame_id);</span><br><span class="line">  disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, page-&gt;data_);</span><br><span class="line">  <span class="comment">// pin it</span></span><br><span class="line">  replacer_-&gt;<span class="built_in">Pin</span>(frame_id);</span><br><span class="line">  page-&gt;pin_count_ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UnpinPageImpl函数实现"><a href="#UnpinPageImpl函数实现" class="headerlink" title="UnpinPageImpl函数实现"></a>UnpinPageImpl函数实现</h3><blockquote>注意这里必须要加锁，以防止并发错误。</blockquote><ul><li>如果我们这个进程已经完成了对该页的操作。我们需要unpin。</li><li>如果该page在缓冲池中，将<code>pin_count</code>减一，如果<code>pin_count</code>为0，unpin该页.</li><li>标注该页为dirty。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManager::UnpinPageImpl</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty)</span> </span>&#123;</span><br><span class="line">  std::scoped_lock lock&#123;latch_&#125;;</span><br><span class="line">  <span class="keyword">auto</span> iter = page_table_.<span class="built_in">find</span>(page_id);</span><br><span class="line">  <span class="comment">// Cannot find the page in buffer pool.</span></span><br><span class="line">  <span class="keyword">if</span> (iter == page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Find the page.</span></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = iter-&gt;second;</span><br><span class="line">  Page *page = &amp;pages_[frame_id];</span><br><span class="line">  <span class="comment">// Check pin count.</span></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;pin_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Do unpin.</span></span><br><span class="line">  page-&gt;pin_count_--;</span><br><span class="line">  <span class="keyword">if</span> (page-&gt;pin_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">    replacer_-&gt;<span class="built_in">Unpin</span>(frame_id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_dirty) &#123;</span><br><span class="line">    page-&gt;is_dirty_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FlushPageImpl函数实现"><a href="#FlushPageImpl函数实现" class="headerlink" title="FlushPageImpl函数实现"></a>FlushPageImpl函数实现</h3><blockquote>注意这里必须要加锁，以防止并发错误。</blockquote><ul><li>这个函数是要把一个page写入磁盘。</li><li>在缓冲中找到该页，调用<code>WritePage</code>，并标记该页非脏。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManager::FlushPageImpl</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make sure you call DiskManager::WritePage!</span></span><br><span class="line">  std::scoped_lock lock&#123;latch_&#125;;</span><br><span class="line">  <span class="keyword">auto</span> iter = page_table_.<span class="built_in">find</span>(page_id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (iter == page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = iter-&gt;second;</span><br><span class="line">  Page *page = &amp;pages_[frame_id];</span><br><span class="line">  <span class="comment">// Write the dirty page into disk.</span></span><br><span class="line">  disk_manager_-&gt;<span class="built_in">WritePage</span>(page-&gt;page_id_, page-&gt;data_);</span><br><span class="line">  page-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NewPageImpl函数实现"><a href="#NewPageImpl函数实现" class="headerlink" title="NewPageImpl函数实现"></a>NewPageImpl函数实现</h3><blockquote>注意这里必须要加锁，以防止并发错误。</blockquote><ul><li>这个函数是要从<code>DiskManager</code>中分配一个新页到缓冲池。</li><li>在缓冲中找不到位置，且没有牺牲页，返回空指针。</li><li>找到<code>frame_id</code>， 更新数据，pin住该页。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Page *<span class="title">BufferPoolManager::NewPageImpl</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 0.   Make sure you call DiskManager::AllocatePage!</span></span><br><span class="line">  <span class="comment">// 1.   If all the pages in the buffer pool are pinned, return nullptr.</span></span><br><span class="line">  <span class="comment">// 2.   Pick a victim page P from either the free list or the replacer. Always pick from the free list first.</span></span><br><span class="line">  <span class="comment">// 3.   Update P&#x27;s metadata, zero out memory and add P to the page table.</span></span><br><span class="line">  <span class="comment">// 4.   Set the page ID output parameter. Return a pointer to P.</span></span><br><span class="line">  std::scoped_lock lock&#123;latch_&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">FindVictimPage</span>(&amp;frame_id)) &#123;  <span class="comment">// Delete page in free list.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Get the frame id.</span></span><br><span class="line">  *page_id = disk_manager_-&gt;<span class="built_in">AllocatePage</span>();</span><br><span class="line">  Page *page = &amp;pages_[frame_id];</span><br><span class="line">  <span class="comment">// Update and pin page.</span></span><br><span class="line">  <span class="built_in">UpdatePage</span>(page, *page_id, frame_id);</span><br><span class="line">  replacer_-&gt;<span class="built_in">Pin</span>(frame_id);</span><br><span class="line">  page-&gt;pin_count_ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DeletePageImpl函数实现"><a href="#DeletePageImpl函数实现" class="headerlink" title="DeletePageImpl函数实现"></a>DeletePageImpl函数实现</h3><blockquote>注意这里必须要加锁，以防止并发错误。</blockquote><ul><li>这里是删除缓冲池中的page。</li><li>在缓冲中找不到该page，返回true。</li><li>找到<code>frame_id</code>，若不是pin状态，删除该页。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManager::DeletePageImpl</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 0.   Make sure you call DiskManager::DeallocatePage!</span></span><br><span class="line">  <span class="comment">// 1.   Search the page table for the requested page (P).</span></span><br><span class="line">  <span class="comment">// 1.   If P does not exist, return true.</span></span><br><span class="line">  <span class="comment">// 2.   If P exists, but has a non-zero pin-count, return false. Someone is using the page.</span></span><br><span class="line">  <span class="comment">// 3.   Otherwise, P can be deleted. Remove P from the page table, reset its metadata and return it to the free list.</span></span><br><span class="line">  std::scoped_lock lock&#123;latch_&#125;;</span><br><span class="line">  <span class="comment">// Cannot find the page.</span></span><br><span class="line">  <span class="keyword">auto</span> iter = page_table_.<span class="built_in">find</span>(page_id);</span><br><span class="line">  <span class="keyword">if</span> (iter == page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Get the frame id.</span></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = iter-&gt;second;</span><br><span class="line">  Page *page = &amp;pages_[frame_id];</span><br><span class="line">  <span class="comment">// Canot delete pin page.</span></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;pin_count_ != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  disk_manager_-&gt;<span class="built_in">DeallocatePage</span>(page_id);</span><br><span class="line">  <span class="built_in">UpdatePage</span>(page, INVALID_PAGE_ID, frame_id);</span><br><span class="line">  free_list_.<span class="built_in">push_back</span>(frame_id);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Test-1"><a href="#Test-1" class="headerlink" title="Test"></a>Test</h3><ul><li><strong>检测语法及格式</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ make format</span><br><span class="line">$ make check-lint</span><br><span class="line">$ make check-clang-tidy</span><br><span class="line">$ make buffer_pool_manager_test</span><br></pre></td></tr></table></figure><ul><li><strong>测试</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ ./test/buffer_pool_manager_test </span><br><span class="line">Running main() from gmock_main.cc</span><br><span class="line">[==========] Running 2 tests from 1 <span class="built_in">test</span> suite.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 2 tests from BufferPoolManagerTest</span><br><span class="line">[ RUN      ] BufferPoolManagerTest.BinaryDataTest</span><br><span class="line">[       OK ] BufferPoolManagerTest.BinaryDataTest (0 ms)</span><br><span class="line">[ RUN      ] BufferPoolManagerTest.SampleTest</span><br><span class="line">[       OK ] BufferPoolManagerTest.SampleTest (0 ms)</span><br><span class="line">[----------] 2 tests from BufferPoolManagerTest (1 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global <span class="built_in">test</span> environment tear-down</span><br><span class="line">[==========] 2 tests from 1 <span class="built_in">test</span> suite ran. (1 ms total)</span><br><span class="line">[  PASSED  ] 2 tests.</span><br></pre></td></tr></table></figure><ul><li><strong>gradescope测试</strong></li></ul><img src="/2022/08/29/lab1/grade.png" class="">]]></content>
    
    
    <summary type="html">&lt;style&gt;
@import url(https://fonts.googleapis.com/css?family=Roboto);
blockquote {
 /* color:#888; */
 background-color: #f9f2f4;
 border-left: 0.2em solid #FA7298;
 padding: 1em 0.7em 1em 0.7em;
 position: relative;
 /* font-family: &#39;Roboto&#39;, sans-serif; */
 line-height: 150%;
 border-radius: 3px;
 /* text-indent: 35px; */
}
&lt;/style&gt;
&lt;h1 id=&quot;Task1-LRU-REPLACEMENT-POLICY&quot;&gt;&lt;a href=&quot;#Task1-LRU-REPLACEMENT-POLICY&quot; class=&quot;headerlink&quot; title=&quot;Task1 LRU REPLACEMENT POLICY&quot;&gt;&lt;/a&gt;Task1 LRU REPLACEMENT POLICY&lt;/h1&gt;&lt;h2 id=&quot;任务描述&quot;&gt;&lt;a href=&quot;#任务描述&quot; class=&quot;headerlink&quot; title=&quot;任务描述&quot;&gt;&lt;/a&gt;任务描述&lt;/h2&gt;&lt;p&gt;这个任务要求我们实现在课堂上所描述的LRU算法。&lt;/p&gt;
&lt;p&gt;你需要实现下面这些函数。请确保他们都是线程安全的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Victim(T*)&lt;/code&gt; :  Remove the object that was accessed the least recently compared to all the elements being tracked by the Replacer, store its contents in the output parameter and return True. If the Replacer is empty return False.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Pin(T)&lt;/code&gt; :This method should be called after a page is pinned to a frame in the BufferPoolManager. It should remove the frame containing the pinned page from the LRUReplacer.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Unpin(T)&lt;/code&gt; : This method should be called when the pin_count of a page becomes 0. This method should add the frame containing the unpinned page to the LRUReplacer.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Size()&lt;/code&gt; : This method returns the number of frames that are currently in the LRUReplacer.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="CMU15-445" scheme="http://zyyyyy.com/categories/CMU15-445/"/>
    
    
    <category term="LRU算法" scheme="http://zyyyyy.com/tags/LRU%E7%AE%97%E6%B3%95/"/>
    
    <category term="Buffer Pool" scheme="http://zyyyyy.com/tags/Buffer-Pool/"/>
    
    <category term="数据库存储" scheme="http://zyyyyy.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>Count Partitions(整数划分)</title>
    <link href="http://zyyyyy.com/2022/08/29/count-partition/"/>
    <id>http://zyyyyy.com/2022/08/29/count-partition/</id>
    <published>2022-08-29T06:42:49.800Z</published>
    <updated>2022-09-16T16:08:11.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a><strong>问题描述：</strong></h1><img src="/2022/08/29/count-partition/par.png" class=""><span id="more"></span><h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a><strong>思路：</strong></h1><h2 id="基本情况（Base-case）"><a href="#基本情况（Base-case）" class="headerlink" title="基本情况（Base case）"></a>基本情况（Base case）</h2><ul><li><strong>当n &#x3D; 0时， 仅有 0 &#x3D; 0一种划分，返回1</strong></li><li><strong>当n &lt; 0时， 递归过界，返回0</strong></li><li><strong>当k &#x3D; 0时， 无法划分，返回0</strong></li></ul><h2 id="递推方法-Recursive-calls"><a href="#递推方法-Recursive-calls" class="headerlink" title="递推方法(Recursive calls)"></a><strong>递推方法(Recursive calls)</strong></h2><ul><li><strong>Q(n,m)&#x3D;Q(n,m-1)+Q(n-m,m)</strong><br> 等式右边第一部分Q(n,m-1)表示被加数不包含m的分划的数目，第二部分表示被加数中包含（注意不是小于）m的分划的数目，因为如果确定了一个分划的被加数中包含m,则剩下的部分就是对n-m进行不超过m的划分。</li></ul><h1 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a><strong>代码如下：</strong></h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_partitions</span>(<span class="params">n, k</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; count_partitions(5, 3)</span></span><br><span class="line"><span class="string">    5</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; count_partitions(6, 4)</span></span><br><span class="line"><span class="string">    9</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> n &lt; <span class="number">0</span> <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> count_partitions(n , k - <span class="number">1</span>) + count_partitions(n - k, k)</span><br></pre></td></tr></table></figure><h2 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ python3 -m doctest count_partiton.py -v</span><br><span class="line">Trying:</span><br><span class="line">    count_partitions(5, 3)</span><br><span class="line">Expecting:</span><br><span class="line">    5</span><br><span class="line">ok</span><br><span class="line">Trying:</span><br><span class="line">    count_partitions(6, 4)</span><br><span class="line">Expecting:</span><br><span class="line">    9</span><br><span class="line">ok</span><br><span class="line">1 items had no tests:</span><br><span class="line">    count_partiton</span><br><span class="line">1 items passed all tests:</span><br><span class="line">   2 tests <span class="keyword">in</span> count_partiton.count_partitions</span><br><span class="line">2 tests <span class="keyword">in</span> 2 items.</span><br><span class="line">2 passed and 0 failed.</span><br><span class="line">Test passed.</span><br></pre></td></tr></table></figure><h1 id="递归树："><a href="#递归树：" class="headerlink" title="递归树："></a>递归树：</h1><img src="/2022/08/29/count-partition/tree.png" class="">]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;&lt;/h1&gt;&lt;img src=&quot;/2022/08/29/count-partition/par.png&quot; class=&quot;&quot;&gt;</summary>
    
    
    
    <category term="CS基础知识" scheme="http://zyyyyy.com/categories/CS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="递归算法" scheme="http://zyyyyy.com/tags/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>

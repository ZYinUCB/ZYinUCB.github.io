<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="baidu-site-verification" content="code-sCk0uhlAgd"><meta name="google-site-verification" content="hrHC9JU3Aurcz5NcTg-atIUsx8rQFfqroNct6DHERFY"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/lo32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/lo16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css"><script src="/lib/pace/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"zyyyyy.com",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="@import url(https:&#x2F;&#x2F;fonts.googleapis.com&#x2F;css?family&#x3D;Roboto); blockquote {  &#x2F;* color:#888; *&#x2F;  background-color: #f9f2f4;  border-left: 0.2em solid #FA7298;  padding: 1em 0.7em 1em 0.7em;  position: r"><meta property="og:type" content="article"><meta property="og:title" content="CMU15-445 lab01"><meta property="og:url" content="http://zyyyyy.com/2022/08/29/lab1/index.html"><meta property="og:site_name" content="禅茶一味"><meta property="og:description" content="@import url(https:&#x2F;&#x2F;fonts.googleapis.com&#x2F;css?family&#x3D;Roboto); blockquote {  &#x2F;* color:#888; *&#x2F;  background-color: #f9f2f4;  border-left: 0.2em solid #FA7298;  padding: 1em 0.7em 1em 0.7em;  position: r"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://zyyyyy.com/2022/08/29/lab1/grade.png"><meta property="article:published_time" content="2022-08-29T07:17:19.000Z"><meta property="article:modified_time" content="2022-09-02T12:07:38.340Z"><meta property="article:author" content="明天再说"><meta property="article:tag" content="LRU算法"><meta property="article:tag" content="Buffer Pool"><meta property="article:tag" content="数据库存储"><meta property="article:tag" content="Algorithm"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://zyyyyy.com/2022/08/29/lab1/grade.png"><link rel="canonical" href="http://zyyyyy.com/2022/08/29/lab1/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>CMU15-445 lab01 | 禅茶一味</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="禅茶一味" type="application/atom+xml"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">禅茶一味</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">明天再说的自留地</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-message"><a href="/message/" rel="section"><i class="fa fa-sticky-note fa-fw"></i>留言板</a></li><li class="menu-item menu-item-toy"><a href="/toy/" rel="section"><i class="fa fa-rocket fa-fw"></i>实用工具</a></li><li class="menu-item menu-item-links"><a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友情链接</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://zyyyyy.com/2022/08/29/lab1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="明天再说"><meta itemprop="description" content="选择有时候比努力更重要"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="禅茶一味"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">CMU15-445 lab01</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-08-29 15:17:19" itemprop="dateCreated datePublished" datetime="2022-08-29T15:17:19+08:00">2022-08-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-09-02 20:07:38" itemprop="dateModified" datetime="2022-09-02T20:07:38+08:00">2022-09-02</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/CMU15-445/" itemprop="url" rel="index"><span itemprop="name">CMU15-445</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2022/08/29/lab1/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2022/08/29/lab1/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>11k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>10 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><style>@import url(https://fonts.googleapis.com/css?family=Roboto);blockquote{background-color:#f9f2f4;border-left:.2em solid #fa7298;padding:1em .7em 1em .7em;position:relative;line-height:150%;border-radius:3px}</style><h1 id="1-Task1-LRU-REPLACEMENT-POLICY"><a href="#1-Task1-LRU-REPLACEMENT-POLICY" class="headerlink" title="1. Task1 LRU REPLACEMENT POLICY"></a>1. Task1 LRU REPLACEMENT POLICY</h1><h2 id="0-任务描述"><a href="#0-任务描述" class="headerlink" title="0. 任务描述"></a>0. 任务描述</h2><p>这个任务要求我们实现在课堂上所描述的LRU算法。</p><p>你需要实现下面这些函数。请确保他们都是线程安全的。</p><ul><li><p><code>Victim(T*)</code> : Remove the object that was accessed the least recently compared to all the elements being tracked by the Replacer, store its contents in the output parameter and return True. If the Replacer is empty return False.</p></li><li><p><code>Pin(T)</code> :This method should be called after a page is pinned to a frame in the BufferPoolManager. It should remove the frame containing the pinned page from the LRUReplacer.</p></li><li><p><code>Unpin(T)</code> : This method should be called when the pin_count of a page becomes 0. This method should add the frame containing the unpinned page to the LRUReplacer.</p></li><li><p><code>Size()</code> : This method returns the number of frames that are currently in the LRUReplacer.</p></li></ul><span id="more"></span><h2 id="1-LRU实现"><a href="#1-LRU实现" class="headerlink" title="1. LRU实现"></a>1. LRU实现</h2><h3 id="1-1-基本数据结构"><a href="#1-1-基本数据结构" class="headerlink" title="1.1 基本数据结构"></a>1.1 基本数据结构</h3><blockquote>LRU 算法的设计原则是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。</blockquote><ul><li>考虑到线程安全及并发错误， 需要在函数中加入<code>latch</code>锁。</li><li><code>capacity</code>表示replacer的容量。</li><li><code>lru_list</code>为双向链表，记录replacer的frame。</li><li>使用<code>lruMap</code>哈希表+双链表的结构，哈希表存储frame id以及指向<code>lru_list</code>内frame的begin指针，让插入和删除复杂度均为O(1)。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::mutex latch;  <span class="comment">// thread safety</span></span><br><span class="line">  <span class="type">size_t</span> capacity;   <span class="comment">// max number of pages LRUReplacer can handle</span></span><br><span class="line">  std::list&lt;<span class="type">frame_id_t</span>&gt; lru_list;</span><br><span class="line">  std::unordered_map&lt;<span class="type">frame_id_t</span>, std::list&lt;<span class="type">frame_id_t</span>&gt;::iterator&gt; lruMap;</span><br></pre></td></tr></table></figure><h3 id="1-2-Victim-函数实现"><a href="#1-2-Victim-函数实现" class="headerlink" title="1.2 Victim 函数实现"></a>1.2 Victim 函数实现</h3><blockquote>注意这里必须要加锁，以防止并发错误。</blockquote><ul><li>使用<code>std::scoped_lock</code>c++17中的scope锁，它能够避免死锁发生，其构造函数能够自动进行上锁操作，析构函数会对互斥量进行解锁操作，保证线程安全。</li><li>如果replacer为空，意味着找不到牺牲页，返回<code>false</code>。</li><li>如果replacer非空，删除最久未使用的页面。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LRUReplacer::Victim</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> </span>&#123;</span><br><span class="line">  std::scoped_lock lock&#123;latch&#125;;</span><br><span class="line">  <span class="comment">// If empty, it means that no victim can be found.</span></span><br><span class="line">  <span class="keyword">if</span> (lruMap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Find the last frame and remove it.</span></span><br><span class="line">  *frame_id = lru_list.<span class="built_in">back</span>();</span><br><span class="line">  lruMap.<span class="built_in">erase</span>(*frame_id);</span><br><span class="line">  lru_list.<span class="built_in">pop_back</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-pin-函数实现"><a href="#1-3-pin-函数实现" class="headerlink" title="1.3 pin 函数实现"></a>1.3 pin 函数实现</h3><blockquote>注意这里必须要加锁，以防止并发错误。</blockquote><ul><li>pin的作用是标记该页（如正在使用），防止并发错误。</li><li>如果找到该frame, 将其从replacer中删除。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUReplacer::Pin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  std::scoped_lock lock&#123;latch&#125;;</span><br><span class="line">  <span class="comment">// Find the frame and pin it.</span></span><br><span class="line">  <span class="keyword">auto</span> it = lruMap.<span class="built_in">find</span>(frame_id);</span><br><span class="line">  <span class="keyword">if</span> (it != lruMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    lru_list.<span class="built_in">erase</span>(lruMap[frame_id]);</span><br><span class="line">    lruMap.<span class="built_in">erase</span>(frame_id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-unpin-函数实现"><a href="#1-4-unpin-函数实现" class="headerlink" title="1.4 unpin 函数实现"></a>1.4 unpin 函数实现</h3><blockquote>注意这里必须要加锁，以防止并发错误。</blockquote><ul><li>unpin的作用是取消标记，将该页加入replacer中。</li><li>如果在replacer中找不到该frame，且replacer不满，加入该frame。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUReplacer::Unpin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  std::scoped_lock lock&#123;latch&#125;;</span><br><span class="line">  <span class="comment">// If exist, do nothing.</span></span><br><span class="line">  <span class="keyword">auto</span> it = lruMap.<span class="built_in">find</span>(frame_id);</span><br><span class="line">  <span class="keyword">if</span> (it != lruMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if list size &gt;= capacity, do nothing</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Size</span>() &gt;= capacity) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// insert</span></span><br><span class="line">  lru_list.<span class="built_in">push_front</span>(frame_id);</span><br><span class="line">  lruMap.<span class="built_in">emplace</span>(frame_id, lru_list.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-Test"><a href="#1-5-Test" class="headerlink" title="1.5 Test"></a>1.5 Test</h3><ul><li><strong>检测语法及格式</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ make format</span><br><span class="line">$ make check-lint</span><br><span class="line">$ make check-clang-tidy</span><br><span class="line">$ make lru_replacer_test</span><br></pre></td></tr></table></figure><ul><li><strong>测试</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ./test/lru_replacer_test</span><br><span class="line">Running main() from gmock_main.cc</span><br><span class="line">[==========] Running 1 <span class="built_in">test</span> from 1 <span class="built_in">test</span> suite.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 1 <span class="built_in">test</span> from LRUReplacerTest</span><br><span class="line">[ RUN      ] LRUReplacerTest.SampleTest</span><br><span class="line">[       OK ] LRUReplacerTest.SampleTest (0 ms)</span><br><span class="line">[----------] 1 <span class="built_in">test</span> from LRUReplacerTest (0 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global <span class="built_in">test</span> environment tear-down</span><br><span class="line">[==========] 1 <span class="built_in">test</span> from 1 <span class="built_in">test</span> suite ran. (0 ms total)</span><br><span class="line">[  PASSED  ] 1 <span class="built_in">test</span>.</span><br></pre></td></tr></table></figure><h1 id="2-Task2-BUFFER-POOL-MANAGER"><a href="#2-Task2-BUFFER-POOL-MANAGER" class="headerlink" title="2. Task2 BUFFER POOL MANAGER"></a>2. Task2 BUFFER POOL MANAGER</h1><h2 id="0-任务描述-1"><a href="#0-任务描述-1" class="headerlink" title="0. 任务描述"></a>0. 任务描述</h2><p>接下来，您需要在系统中实现缓冲池管理器<code>(BufferPoolManager)</code>。<code>BufferPoolManager</code>负责从<code>DiskManager</code>获取数据库页面并将它们存储在内存中。<code>BufferPoolManage</code>还可以在有要求它这样做时，或者当它需要驱逐一个页以便为新页腾出空间时，将脏页写入磁盘。为了确保您的实现能够正确地与系统的其余部分一起工作，我们将为您提供一些已经填写好的功能。您也不需要实现实际读写数据到磁盘的代码(在我们的实现中称为<code>DiskManager</code>)。我们将为您提供这一功能。</p><p>系统中的所有内存页面均由<code>Page</code>对象表示。<code>BufferPoolManager</code>不需要了解这些页面的内容。 但是，作为系统开发人员，重要的是要了解Page对象只是缓冲池中用于存储内存的容器，因此并不特定于唯一页面。 也就是说，每个<code>Page</code>对象都包含一块内存，<code>DiskManager</code>会将其用作复制从磁盘读取的物理页面内容的位置。 <code>BufferPoolManager</code>将在将其来回移动到磁盘时重用相同的<code>Page</code>对象来存储数据。 这意味着在系统的整个生命周期中，相同的<code>Page</code>对象可能包含不同的物理页面。<code>Page</code>对象的标识符（<code>page_id</code>）跟踪其包含的物理页面。 如果<code>Page</code>对象不包含物理页面，则必须将其<code>page_id</code>设置为<code>INVALID_PAGE_ID</code>。</p><p>每个<code>Page</code>对象还维护一个计数器，以显示“固定”该页面的线程数。<code>BufferPoolManager</code>不允许释放固定的页面。每个<code>Page</code>对象还跟踪它的脏标记。您的工作是判断页面在解绑定之前是否已经被修改（修改则把脏标记置为1）。<code>BufferPoolManager</code>必须将脏页的内容写回磁盘，然后才能重用该对象。</p><p><code>BufferPoolManager</code>实现将使用在此分配的前面步骤中创建的<code>LRUReplacer</code>类。它将使用<code>LRUReplacer</code>来跟踪何时访问页对象，以便在必须释放一个帧以为从磁盘复制新的物理页腾出空间时，它可以决定取消哪个页对象</p><p>你需要实现在(src&#x2F;buffer&#x2F;buffer_pool_manager.cpp):的以下函数</p><ul><li><code>FetchPageImpl(page_id)</code></li><li><code>NewPageImpl(page_id)</code></li><li><code>UnpinPageImpl(page_id, is_dirty)</code></li><li><code>FlushPageImpl(page_id)</code></li><li><code>DeletePageImpl(page_id)</code></li><li><code>FlushAllPagesImpl()</code></li></ul><h2 id="1-BufferPool实现"><a href="#1-BufferPool实现" class="headerlink" title="1. BufferPool实现"></a>1. BufferPool实现</h2><h3 id="1-1-基本数据结构-1"><a href="#1-1-基本数据结构-1" class="headerlink" title="1.1 基本数据结构"></a>1.1 基本数据结构</h3><ul><li><code>pool_size_</code>表示缓冲池的最大容量。</li><li><code>*pages_</code>指向缓冲池中page数组，用<code>pages_ = new Page[pool_size_]</code>来初始化。</li><li><code>page_table_</code>是页表，page_id标识磁盘页，页表记录了该page在磁盘中的page_id和对应缓冲池中的frame_id。</li><li><code>free_list</code>里面存的是frame_id，具体来说就是还没有被分配的缓冲池的数组项</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Number of pages in the buffer pool. */</span></span><br><span class="line"><span class="type">size_t</span> pool_size_;</span><br><span class="line"><span class="comment">/** Array of buffer pool pages. */</span></span><br><span class="line">Page *pages_;</span><br><span class="line"><span class="comment">/** Page table for keeping track of buffer pool pages. */</span></span><br><span class="line">std::unordered_map&lt;<span class="type">page_id_t</span>, <span class="type">frame_id_t</span>&gt; page_table_;</span><br><span class="line"><span class="comment">/** List of free pages. */</span></span><br><span class="line">std::list&lt;<span class="type">frame_id_t</span>&gt; free_list_;</span><br></pre></td></tr></table></figure><h3 id="1-2-UpdatePage函数实现"><a href="#1-2-UpdatePage函数实现" class="headerlink" title="1.2 UpdatePage函数实现"></a>1.2 UpdatePage函数实现</h3><ul><li>这是一个辅助函数，目的是更新页表中的数据。</li><li>如果是脏页，需要先将数据写回磁盘。</li><li>如果不是脏页，更新页表中的id。</li><li>最后清空该页，更新id。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferPoolManager::UpdatePage</span><span class="params">(Page *page, <span class="type">page_id_t</span> new_page_id, <span class="type">frame_id_t</span> new_frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (page-&gt;<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">    disk_manager_-&gt;<span class="built_in">WritePage</span>(page-&gt;page_id_, page-&gt;data_);</span><br><span class="line">    page-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Put the new page in page table.</span></span><br><span class="line">  page_table_.<span class="built_in">erase</span>(page-&gt;page_id_);</span><br><span class="line">  <span class="keyword">if</span> (new_page_id != INVALID_PAGE_ID) &#123;</span><br><span class="line">    page_table_.<span class="built_in">emplace</span>(new_page_id, new_frame_id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make the page data empty.</span></span><br><span class="line">  page-&gt;<span class="built_in">ResetMemory</span>();</span><br><span class="line">  page-&gt;page_id_ = new_page_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-FindVictimPage函数实现"><a href="#1-2-FindVictimPage函数实现" class="headerlink" title="1.2 FindVictimPage函数实现"></a>1.2 FindVictimPage函数实现</h3><ul><li>这是一个辅助函数，目的是找到牺牲页。</li><li>如果<code>free_list_</code>不满，意味着buffer pool还有空位，找到<code>frame_id</code>。</li><li>如果缓冲池已满，调用LRU算法找牺牲页。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManager::FindVictimPage</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Buffer pool is not full. Get the frame id from free_list.</span></span><br><span class="line">  <span class="keyword">if</span> (!free_list_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    *frame_id = free_list_.<span class="built_in">front</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Buffer pool is full. Use LRU algorithm.</span></span><br><span class="line">  <span class="keyword">return</span> replacer_-&gt;<span class="built_in">Victim</span>(frame_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-FetchPageImpl函数实现"><a href="#1-4-FetchPageImpl函数实现" class="headerlink" title="1.4 FetchPageImpl函数实现"></a>1.4 FetchPageImpl函数实现</h3><blockquote>注意这里必须要加锁，以防止并发错误。</blockquote><ul><li>如果能在<code>page_table_</code>页表中找到该页，调用<code>replacer</code>将其pin出。</li><li>如果找不到，说明该page不在缓冲池中，而在磁盘中，调用<code>FindVictimPage</code>在缓冲池中找到<code>frame</code>。</li><li>通过<code>frame_id</code>找到相应的<code>page</code>，更新数据，别忘了pin住该页。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Page *<span class="title">BufferPoolManager::FetchPageImpl</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.     Search the page table for the requested page (P).</span></span><br><span class="line">  <span class="comment">// 1.1    If P exists, pin it and return it immediately.</span></span><br><span class="line">  <span class="comment">// 1.2    If P does not exist, find a replacement page (R) from either the free list or the replacer.</span></span><br><span class="line">  <span class="comment">//        Note that pages are always found from the free list first.</span></span><br><span class="line">  <span class="comment">// 2.     If R is dirty, write it back to the disk.</span></span><br><span class="line">  <span class="comment">// 3.     Delete R from the page table and insert P.</span></span><br><span class="line">  <span class="comment">// 4.     Update P&#x27;s metadata, read in the page content from disk, and then return a pointer to P.</span></span><br><span class="line">  std::scoped_lock lock&#123;latch_&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> iter = page_table_.<span class="built_in">find</span>(page_id);</span><br><span class="line">  <span class="keyword">if</span> (iter != page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// Find the frame id through page table.</span></span><br><span class="line">    <span class="type">frame_id_t</span> frame_id = iter-&gt;second;</span><br><span class="line">    Page *page = &amp;pages_[frame_id];</span><br><span class="line">    <span class="comment">// Pin it and and record it in pin count.</span></span><br><span class="line">    replacer_-&gt;<span class="built_in">Pin</span>(frame_id);</span><br><span class="line">    page-&gt;pin_count_++;</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cannot find. It means that this page is in the disk.</span></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// Find the victim page and insert the disk page instead.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">FindVictimPage</span>(&amp;frame_id)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find the page and get the frame id.</span></span><br><span class="line">  Page *page = &amp;pages_[frame_id];</span><br><span class="line">  <span class="built_in">UpdatePage</span>(page, page_id, frame_id);</span><br><span class="line">  disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, page-&gt;data_);</span><br><span class="line">  <span class="comment">// pin it</span></span><br><span class="line">  replacer_-&gt;<span class="built_in">Pin</span>(frame_id);</span><br><span class="line">  page-&gt;pin_count_ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-UnpinPageImpl函数实现"><a href="#1-5-UnpinPageImpl函数实现" class="headerlink" title="1.5 UnpinPageImpl函数实现"></a>1.5 UnpinPageImpl函数实现</h3><blockquote>注意这里必须要加锁，以防止并发错误。</blockquote><ul><li>如果我们这个进程已经完成了对该页的操作。我们需要unpin。</li><li>如果该page在缓冲池中，将<code>pin_count</code>减一，如果<code>pin_count</code>为0，unpin该页.</li><li>标注该页为dirty。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManager::UnpinPageImpl</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty)</span> </span>&#123;</span><br><span class="line">  std::scoped_lock lock&#123;latch_&#125;;</span><br><span class="line">  <span class="keyword">auto</span> iter = page_table_.<span class="built_in">find</span>(page_id);</span><br><span class="line">  <span class="comment">// Cannot find the page in buffer pool.</span></span><br><span class="line">  <span class="keyword">if</span> (iter == page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Find the page.</span></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = iter-&gt;second;</span><br><span class="line">  Page *page = &amp;pages_[frame_id];</span><br><span class="line">  <span class="comment">// Check pin count.</span></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;pin_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Do unpin.</span></span><br><span class="line">  page-&gt;pin_count_--;</span><br><span class="line">  <span class="keyword">if</span> (page-&gt;pin_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">    replacer_-&gt;<span class="built_in">Unpin</span>(frame_id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_dirty) &#123;</span><br><span class="line">    page-&gt;is_dirty_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-FlushPageImpl函数实现"><a href="#1-6-FlushPageImpl函数实现" class="headerlink" title="1.6 FlushPageImpl函数实现"></a>1.6 FlushPageImpl函数实现</h3><blockquote>注意这里必须要加锁，以防止并发错误。</blockquote><ul><li>这个函数是要把一个page写入磁盘。</li><li>在缓冲中找到该页，调用<code>WritePage</code>，并标记该页非脏。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManager::FlushPageImpl</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make sure you call DiskManager::WritePage!</span></span><br><span class="line">  std::scoped_lock lock&#123;latch_&#125;;</span><br><span class="line">  <span class="keyword">auto</span> iter = page_table_.<span class="built_in">find</span>(page_id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (iter == page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = iter-&gt;second;</span><br><span class="line">  Page *page = &amp;pages_[frame_id];</span><br><span class="line">  <span class="comment">// Write the dirty page into disk.</span></span><br><span class="line">  disk_manager_-&gt;<span class="built_in">WritePage</span>(page-&gt;page_id_, page-&gt;data_);</span><br><span class="line">  page-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-NewPageImpl函数实现"><a href="#1-7-NewPageImpl函数实现" class="headerlink" title="1.7 NewPageImpl函数实现"></a>1.7 NewPageImpl函数实现</h3><blockquote>注意这里必须要加锁，以防止并发错误。</blockquote><ul><li>这个函数是要从<code>DiskManager</code>中分配一个新页到缓冲池。</li><li>在缓冲中找不到位置，且没有牺牲页，返回空指针。</li><li>找到<code>frame_id</code>， 更新数据，pin住该页。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Page *<span class="title">BufferPoolManager::NewPageImpl</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 0.   Make sure you call DiskManager::AllocatePage!</span></span><br><span class="line">  <span class="comment">// 1.   If all the pages in the buffer pool are pinned, return nullptr.</span></span><br><span class="line">  <span class="comment">// 2.   Pick a victim page P from either the free list or the replacer. Always pick from the free list first.</span></span><br><span class="line">  <span class="comment">// 3.   Update P&#x27;s metadata, zero out memory and add P to the page table.</span></span><br><span class="line">  <span class="comment">// 4.   Set the page ID output parameter. Return a pointer to P.</span></span><br><span class="line">  std::scoped_lock lock&#123;latch_&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">FindVictimPage</span>(&amp;frame_id)) &#123;  <span class="comment">// Delete page in free list.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Get the frame id.</span></span><br><span class="line">  *page_id = disk_manager_-&gt;<span class="built_in">AllocatePage</span>();</span><br><span class="line">  Page *page = &amp;pages_[frame_id];</span><br><span class="line">  <span class="comment">// Update and pin page.</span></span><br><span class="line">  <span class="built_in">UpdatePage</span>(page, *page_id, frame_id);</span><br><span class="line">  replacer_-&gt;<span class="built_in">Pin</span>(frame_id);</span><br><span class="line">  page-&gt;pin_count_ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-DeletePageImpl函数实现"><a href="#1-8-DeletePageImpl函数实现" class="headerlink" title="1.8 DeletePageImpl函数实现"></a>1.8 DeletePageImpl函数实现</h3><blockquote>注意这里必须要加锁，以防止并发错误。</blockquote><ul><li>这里是删除缓冲池中的page。</li><li>在缓冲中找不到该page，返回true。</li><li>找到<code>frame_id</code>，若不是pin状态，删除该页。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManager::DeletePageImpl</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 0.   Make sure you call DiskManager::DeallocatePage!</span></span><br><span class="line">  <span class="comment">// 1.   Search the page table for the requested page (P).</span></span><br><span class="line">  <span class="comment">// 1.   If P does not exist, return true.</span></span><br><span class="line">  <span class="comment">// 2.   If P exists, but has a non-zero pin-count, return false. Someone is using the page.</span></span><br><span class="line">  <span class="comment">// 3.   Otherwise, P can be deleted. Remove P from the page table, reset its metadata and return it to the free list.</span></span><br><span class="line">  std::scoped_lock lock&#123;latch_&#125;;</span><br><span class="line">  <span class="comment">// Cannot find the page.</span></span><br><span class="line">  <span class="keyword">auto</span> iter = page_table_.<span class="built_in">find</span>(page_id);</span><br><span class="line">  <span class="keyword">if</span> (iter == page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Get the frame id.</span></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = iter-&gt;second;</span><br><span class="line">  Page *page = &amp;pages_[frame_id];</span><br><span class="line">  <span class="comment">// Canot delete pin page.</span></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;pin_count_ != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  disk_manager_-&gt;<span class="built_in">DeallocatePage</span>(page_id);</span><br><span class="line">  <span class="built_in">UpdatePage</span>(page, INVALID_PAGE_ID, frame_id);</span><br><span class="line">  free_list_.<span class="built_in">push_back</span>(frame_id);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-9-Test"><a href="#1-9-Test" class="headerlink" title="1.9 Test"></a>1.9 Test</h3><ul><li><strong>检测语法及格式</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ make format</span><br><span class="line">$ make check-lint</span><br><span class="line">$ make check-clang-tidy</span><br><span class="line">$ make buffer_pool_manager_test</span><br></pre></td></tr></table></figure><ul><li><strong>测试</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ ./test/buffer_pool_manager_test </span><br><span class="line">Running main() from gmock_main.cc</span><br><span class="line">[==========] Running 2 tests from 1 <span class="built_in">test</span> suite.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 2 tests from BufferPoolManagerTest</span><br><span class="line">[ RUN      ] BufferPoolManagerTest.BinaryDataTest</span><br><span class="line">[       OK ] BufferPoolManagerTest.BinaryDataTest (0 ms)</span><br><span class="line">[ RUN      ] BufferPoolManagerTest.SampleTest</span><br><span class="line">[       OK ] BufferPoolManagerTest.SampleTest (0 ms)</span><br><span class="line">[----------] 2 tests from BufferPoolManagerTest (1 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global <span class="built_in">test</span> environment tear-down</span><br><span class="line">[==========] 2 tests from 1 <span class="built_in">test</span> suite ran. (1 ms total)</span><br><span class="line">[  PASSED  ] 2 tests.</span><br></pre></td></tr></table></figure><ul><li><strong>gradescope测试</strong></li></ul><img src="/2022/08/29/lab1/grade.png"></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>明天再说</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://zyyyyy.com/2022/08/29/lab1/" title="CMU15-445 lab01">http://zyyyyy.com/2022/08/29/lab1/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/LRU%E7%AE%97%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> LRU算法</a> <a href="/tags/Buffer-Pool/" rel="tag"><i class="fa fa-tag"></i> Buffer Pool</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8/" rel="tag"><i class="fa fa-tag"></i> 数据库存储</a> <a href="/tags/Algorithm/" rel="tag"><i class="fa fa-tag"></i> Algorithm</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2022/08/29/count-partition/" rel="prev" title="Count Partitions(整数划分)"><i class="fa fa-chevron-left"></i> Count Partitions(整数划分)</a></div><div class="post-nav-item"><a href="/2022/09/02/lab2/" rel="next" title="CMU15-445 lab02(Part 1)">CMU15-445 lab02(Part 1) <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener("tabs:register",()=>{let e=CONFIG.comments["activeClass"];if(e=CONFIG.comments.storage?localStorage.getItem("comments_active")||e:e){let t=document.querySelector(`a[href="#comment-${e}"]`);t&&t.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{t.target.matches(".tabs-comment .tab-content .tab-pane")&&(t=t.target.classList[1],localStorage.setItem("comments_active",t))})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Task1-LRU-REPLACEMENT-POLICY"><span class="nav-number">1.</span> <span class="nav-text">1. Task1 LRU REPLACEMENT POLICY</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0-%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">0. 任务描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-LRU%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.</span> <span class="nav-text">1. LRU实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.1 基本数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Victim-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2 Victim 函数实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-pin-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.3 pin 函数实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-unpin-%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.4.</span> <span class="nav-text">1.4 unpin 函数实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-Test"><span class="nav-number">1.2.5.</span> <span class="nav-text">1.5 Test</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Task2-BUFFER-POOL-MANAGER"><span class="nav-number">2.</span> <span class="nav-text">2. Task2 BUFFER POOL MANAGER</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#0-%E4%BB%BB%E5%8A%A1%E6%8F%8F%E8%BF%B0-1"><span class="nav-number">2.1.</span> <span class="nav-text">0. 任务描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-BufferPool%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.</span> <span class="nav-text">1. BufferPool实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.1 基本数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-UpdatePage%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.2.</span> <span class="nav-text">1.2 UpdatePage函数实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-FindVictimPage%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.3.</span> <span class="nav-text">1.2 FindVictimPage函数实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-FetchPageImpl%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.4.</span> <span class="nav-text">1.4 FetchPageImpl函数实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-UnpinPageImpl%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.5.</span> <span class="nav-text">1.5 UnpinPageImpl函数实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-FlushPageImpl%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.6.</span> <span class="nav-text">1.6 FlushPageImpl函数实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-NewPageImpl%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.7.</span> <span class="nav-text">1.7 NewPageImpl函数实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-DeletePageImpl%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.8.</span> <span class="nav-text">1.8 DeletePageImpl函数实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-Test"><span class="nav-number">2.2.9.</span> <span class="nav-text">1.9 Test</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="明天再说" src="/images/avatar.png"><p class="site-author-name" itemprop="name">明天再说</p><div class="site-description" itemprop="description">选择有时候比努力更重要</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">4</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://git.acwing.com/sitetampo" title="AcGit → https:&#x2F;&#x2F;git.acwing.com&#x2F;sitetampo" rel="noopener" target="_blank"><i class="fab fa-gitlab fa-fw"></i>AcGit</a> </span><span class="links-of-author-item"><a href="mailto:yangzhao2001@berkeley.edu" title="E-Mail → mailto:yangzhao2001@berkeley.edu" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div><div class="links-of-recent-posts motion-element"><div class="links-of-recent-posts-title"><i class="fa fa-history fa-fw"></i> 近期文章</div><ul class="links-of-recent-posts-list"><li class="links-of-recent-posts-item"><a href="/2022/09/02/lab2/" title="2022&#x2F;09&#x2F;02&#x2F;lab2&#x2F;">CMU15-445 lab02(Part 1)</a></li><li class="links-of-recent-posts-item"><a href="/2022/08/29/lab1/" title="2022&#x2F;08&#x2F;29&#x2F;lab1&#x2F;">CMU15-445 lab01</a></li><li class="links-of-recent-posts-item"><a href="/2022/08/29/count-partition/" title="2022&#x2F;08&#x2F;29&#x2F;count-partition&#x2F;">Count Partitions(整数划分)</a></li></ul></div><div style="margin-top:20px"><canvas id="canvas" style="width:60%">当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>!function(){var h,o,r,f,t,e,d=[[[0,0,1,1,1,0,0],[0,1,1,0,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,0,1,1,0],[0,0,1,1,1,0,0]],[[0,0,0,1,1,0,0],[0,1,1,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[1,1,1,1,1,1,1]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,0,0,1,1],[1,1,1,1,1,1,1]],[[1,1,1,1,1,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,0,1,1,1,0],[0,0,1,1,1,1,0],[0,1,1,0,1,1,0],[1,1,0,0,1,1,0],[1,1,1,1,1,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,1,1]],[[1,1,1,1,1,1,1],[1,1,0,0,0,0,0],[1,1,0,0,0,0,0],[1,1,1,1,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[1,1,1,1,1,1,1],[1,1,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,1,1,0,0,0,0]],[[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0]]],i=document.getElementById("canvas");function a(t,e){for(var l=[1,2,3],n=["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"],a=0;a<d[e].length;a++)for(var h,o=0;o<d[e][a].length;o++)1==d[e][a][o]&&(h={x:14*(f+2)*t+2*o*(f+1)+(f+1),y:2*a*(f+1)+(f+1),stepX:Math.floor(4*Math.random()-2),stepY:-2*l[Math.floor(Math.random()*l.length)],color:n[Math.floor(Math.random()*n.length)],disY:1},r.push(h))}function l(){i.height=100;for(var t=0;t<o.length;t++){a=n=l=e=void 0;for(var e=t,l=o[t],n=0;n<d[l].length;n++)for(var a=0;a<d[l][n].length;a++)1==d[l][n][a]&&(h.beginPath(),h.arc(14*(f+2)*e+2*a*(f+1)+(f+1),2*n*(f+1)+(f+1),f,0,2*Math.PI),h.closePath(),h.fill())}for(t=0;t<r.length;t++)h.beginPath(),h.arc(r[t].x,r[t].y,f,0,2*Math.PI),h.fillStyle=r[t].color,h.closePath(),h.fill()}i.getContext&&(h=i.getContext("2d"),i.height=100,i.width=700,h.fillStyle="#f00",h.fillRect(10,10,50,50),o=[],r=[],f=i.height/20-1,e=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date),o.push(e[1],e[2],10,e[3],e[4],10,e[5],e[6]),clearInterval(t),t=setInterval(function(){!function(){var t=[],e=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date),l=[];l.push(e[1],e[2],10,e[3],e[4],10,e[5],e[6]);for(var n=o.length-1;0<=n;n--)l[n]!==o[n]&&t.push(n+"_"+(Number(o[n])+1)%10);for(n=0;n<t.length;n++)a.apply(this,t[n].split("_"));o=l.concat()}();for(var t=0;t<r.length;t++)r[t].stepY+=r[t].disY,r[t].x+=r[t].stepX,r[t].y+=r[t].stepY,(r[t].x>700+f||r[t].y>100+f)&&(r.splice(t,1),t--);l()},50))}()</script></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">明天再说</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">12k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">11 分钟</span></div><div class="busuanzi-count"><script async src="/lib/others/busuanzi.pure.mini.js"></script><span class="site-uv">我的第 <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 位朋友， </span><span class="site-pv">历经 <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次回眸才与你相遇</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i></i> </span><span class="site-uv" title="我的第 undefined 位朋友，"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i></i> </span><span class="site-pv" title="历经 undefined 次回眸才与你相遇"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>!function(){var e,t,o,n,r=document.getElementsByTagName("link");if(0<r.length)for(i=0;i<r.length;i++)"canonical"==r[i].rel.toLowerCase()&&r[i].href&&(e=r[i].href);t=(e||window.location.protocol).split(":")[0],e=e||window.location.href,window,o=e,n=document.referrer,/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi.test(o)||(t="https"===String(t).toLowerCase()?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif",n?(t+="?r="+encodeURIComponent(document.referrer),o&&(t+="&l="+o)):o&&(t+="?l="+o),(new Image).src=t)}()</script><script src="/js/local-search.js"></script><script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script><script>window.addEventListener("load",()=>{quicklink({timeout:3e3,priority:!0,ignores:[i=>i.includes("#"),i=>"http://zyyyyy.com/2022/08/29/lab1/"===i]})})</script><script src="https://unpkg.com/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script><script>var options={bottom:"64px",right:"unset",left:"32px",time:"0.5s",mixColor:"transparent",backgroundColor:"transparent",buttonColorDark:"#100f2c",buttonColorLight:"#fff",saveInCookies:!0,label:"🌓",autoMatchOsTheme:!0};const darkmode=new Darkmode(options);(window.darkmode=darkmode).showWidget()</script><script>NexT.utils.loadComments(document.querySelector("#valine-comments"),()=>{NexT.utils.getScript("//unpkg.com/valine/dist/Valine.min.js",()=>{var i=["nick","mail","link"],e="nick,mail,link".split(",").filter(e=>i.includes(e));new Valine({el:"#valine-comments",verify:!1,notify:!1,appId:"s7DRrQEVq46DTVbzKg03kO9P-gzGzoHsz",appKey:"oLwABKWuUHMb8HS9i6jtmA93",placeholder:"&#x270d;输入你的评论",avatar:"mm",meta:e,pageSize:"10",visitor:!1,lang:"zh-cn",path:location.pathname,recordIP:!1,serverURLs:""})},window.Valine)})</script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"></script><script>function timer(){var e=moment.preciseDiff(moment(),moment(20220829,"YYYYMMDD"));e=(e=(e=(e=(e=(e=(e=e.replace(/years?/,"年")).replace(/months?/,"月")).replace(/days?/,"天")).replace(/hours?/,"小时")).replace(/minutes?/,"分")).replace(/seconds?/,"秒")).replace(/\d+/g,'<span style="color:#1890ff">$&</span>'),div.innerHTML="我已在此等候你 "+e}var div=document.createElement("div"),copyright=document.querySelector(".copyright");document.querySelector(".footer-inner").insertBefore(div,copyright.nextSibling),timer(),setInterval("timer()",1e3)</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,model:{jsonPath:"/live2dw/assets/koharu.model.json"},display:{position:"right",width:150,height:300},mobile:{show:!1},log:!1})</script></body></html><script type="text/javascript" src="/js/src/firework.js"></script>
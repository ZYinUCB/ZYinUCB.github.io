<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CMU15-445 lab02(Part 1)</title>
    <url>/2022/09/02/lab2/</url>
    <content><![CDATA[<!-- <style>
.table-wrapper {
    display: block;
    overflow-x: auto;
}
</style> -->
<h1 id="Task1-B-TREE-PAGES"><a href="#Task1-B-TREE-PAGES" class="headerlink" title="Task1 - B+TREE PAGES"></a>Task1 - B+TREE PAGES</h1><p>您需要实现三个页面类来存储B+树的数据。</p>
<ul>
<li>B+Tree Parent Page</li>
<li>B+Tree Internal Page</li>
<li>B+Tree Leaf Page</li>
</ul>
<span id="more"></span>

<h2 id="1-B-Tree-Parent-Page"><a href="#1-B-Tree-Parent-Page" class="headerlink" title="1. B+ Tree Parent Page"></a>1. B+ Tree Parent Page</h2><p>这是内部页和叶页都继承的父类，它只包含两个子类共享的信息。父页面被划分为如下表所示的几个字段。</p>
<ul>
<li>B+Tree Parent Page Content</li>
</ul>
<div class="table-wrapper"><table>
<thead>
<tr>
<th>Variable Name</th>
<th>Size</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>page_type_</td>
<td>4</td>
<td>Page Type (internal or leaf)</td>
</tr>
<tr>
<td>lsn_</td>
<td>4</td>
<td>Log sequence number (Used in Project 4)</td>
</tr>
<tr>
<td>size_</td>
<td>4</td>
<td>Number of Key &amp; Value pairs in page</td>
</tr>
<tr>
<td>max_size_</td>
<td>4</td>
<td>Max number of Key &amp; Value pairs in page</td>
</tr>
<tr>
<td>parent_page_id_</td>
<td>4</td>
<td>Parent Page Id</td>
</tr>
<tr>
<td>page_id_</td>
<td>4</td>
<td>Self Page Id</td>
</tr>
</tbody>
</table></div>
你必须在指定文件中实现父页。你只允许修改头文件(src/include/storage/page/b_plus_tree_page.h)和它对应的源文件(src/page/b_plus_tree_page.cpp)。


<ul>
<li>这里属于白给送分题，把各种set和get函数填空就行。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> bustub &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Helper methods to get/set page type</span></span><br><span class="line"><span class="comment"> * Page type enum class is defined in b_plus_tree_page.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BPlusTreePage::IsLeafPage</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> page_type_ == IndexPageType::LEAF_PAGE; &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BPlusTreePage::IsRootPage</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> parent_page_id_ == INVALID_PAGE_ID; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPlusTreePage::SetPageType</span><span class="params">(IndexPageType page_type)</span> </span>&#123; page_type_ = page_type; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Helper methods to get/set size (number of key/value pairs stored in that</span></span><br><span class="line"><span class="comment"> * page)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BPlusTreePage::GetSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPlusTreePage::SetSize</span><span class="params">(<span class="type">int</span> size)</span> </span>&#123; size_ = size; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPlusTreePage::IncreaseSize</span><span class="params">(<span class="type">int</span> amount)</span> </span>&#123; size_ += amount; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Helper methods to get/set max size (capacity) of the page</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BPlusTreePage::GetMaxSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> max_size_; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPlusTreePage::SetMaxSize</span><span class="params">(<span class="type">int</span> size)</span> </span>&#123; max_size_ = size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Helper method to get min page size</span></span><br><span class="line"><span class="comment"> * Generally, min page size == max page size / 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BPlusTreePage::GetMinSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> max_size_ / <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Helper methods to get/set parent page id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">page_id_t</span> <span class="title">BPlusTreePage::GetParentPageId</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> parent_page_id_; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPlusTreePage::SetParentPageId</span><span class="params">(<span class="type">page_id_t</span> parent_page_id)</span> </span>&#123; parent_page_id_ = parent_page_id; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Helper methods to get/set self page id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">page_id_t</span> <span class="title">BPlusTreePage::GetPageId</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> page_id_; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPlusTreePage::SetPageId</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123; page_id_ = page_id; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Helper methods to set lsn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BPlusTreePage::SetLSN</span><span class="params">(<span class="type">lsn_t</span> lsn)</span> </span>&#123; lsn_ = lsn; &#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace bustub</span></span><br></pre></td></tr></table></figure>

<h2 id="2-B-TREE-INTERNAL-PAGE"><a href="#2-B-TREE-INTERNAL-PAGE" class="headerlink" title="2. B+TREE INTERNAL PAGE"></a>2. B+TREE INTERNAL PAGE</h2><p>内部页不存储任何实际数据，而是存储有序的m个键条目和m + 1个指针（也称为page_id）。 由于指针的数量不等于键的数量，因此将第一个键设置为无效，并且查找方法应始终从第二个键开始。 任何时候，每个内部页面至少有一半已满。 在删除期间，可以将两个半满页面合并为合法页面，或者可以将其重新分配以避免合并，而在插入期间，可以将一个完整页面分为两部分。</p>
<p>你只能修改头文件(src&#x2F;include&#x2F;storage&#x2F;page&#x2F;b_plus_tree_internal_page.h) 和对应的源文件(src&#x2F;page&#x2F;b_plus_tree_internal_page.cpp).</p>
<ul>
<li>如图所示，第一个node被设置为无效, 没有key值。</li>
</ul>
<img src="/2022/09/02/lab2/t1.jpg" class="">

<h3 id="2-1-类初始化"><a href="#2-1-类初始化" class="headerlink" title="2.1 类初始化"></a>2.1 类初始化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::Init</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">page_id_t</span> parent_id, <span class="type">int</span> max_size)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SetPageType</span>(IndexPageType::INTERNAL_PAGE);</span><br><span class="line">  <span class="built_in">SetPageId</span>(page_id);</span><br><span class="line">  <span class="built_in">SetParentPageId</span>(parent_id);</span><br><span class="line">  <span class="built_in">SetSize</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">SetMaxSize</span>(max_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-基本的数组内部函数"><a href="#2-2-基本的数组内部函数" class="headerlink" title="2.2 基本的数组内部函数"></a>2.2 基本的数组内部函数</h3><ul>
<li><code>array</code>表示中间节点的内部数组。</li>
<li><code>first</code>存key，也就是主键。</li>
<li><code>second</code>存value，即指向子节点的指针。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function">KeyType <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::KeyAt</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array[index].first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::SetKeyAt</span><span class="params">(<span class="type">int</span> index, <span class="type">const</span> KeyType &amp;key)</span> </span>&#123; array[index].first = key; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::ValueIndex</span><span class="params">(<span class="type">const</span> ValueType &amp;value)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">GetSize</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i].second == value) &#123;</span><br><span class="line">      <span class="keyword">return</span> i; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function">ValueType <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::ValueAt</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> array[index].second; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-Lookup函数（内部节点）"><a href="#2-3-Lookup函数（内部节点）" class="headerlink" title="2.3 Lookup函数（内部节点）"></a>2.3 Lookup函数（内部节点）</h3><ul>
<li>这里是让我们查找并返回指向子页面的子指针(page_id)，该页面包含输入“key”。</li>
<li>从第二个键开始搜索(第一个键是无效的)</li>
<li>注意到<code>K(i) &lt;= K &lt; K(i+1)</code>，只需查找小于等于input的最后一个key即可。</li>
<li>这里用y总的<font color=blue><a href="https://www.acwing.com/problem/content/791/">整数二分模板</a></font>，且要注意key比array中所有key都要小的情况。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function">ValueType <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::Lookup</span><span class="params">(<span class="type">const</span> KeyType &amp;key, <span class="type">const</span> KeyComparator &amp;comparator)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> r = <span class="built_in">GetSize</span>() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comparator</span>(<span class="built_in">KeyAt</span>(mid), key) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      l = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">comparator</span>(<span class="built_in">KeyAt</span>(l), key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> array[<span class="number">0</span>].second; <span class="comment">// Cannot find satisdied key. The key is smaller than any valid key.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ValueAt</span>(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-插入函数"><a href="#2-4-插入函数" class="headerlink" title="2.4 插入函数"></a>2.4 插入函数</h3><ul>
<li><code>PopulateNewRoot()</code>填充分裂后新的根节点，只在<code>InsertIntoParent()</code>(b_plus_tree.cpp)中调用。</li>
<li><code>InsertNodeAfter()</code>将<code>new_key</code>和<code>new_value</code>对插入到值为<code>old_value</code>的键值对之后。</li>
<li>先找到存有<code>old_value</code>的键值对，数组下标大于等于insert_index的元素整体后移1位，在空位插入新的node。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::PopulateNewRoot</span><span class="params">(<span class="type">const</span> ValueType &amp;old_value, <span class="type">const</span> KeyType &amp;new_key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                     <span class="type">const</span> ValueType &amp;new_value)</span> </span>&#123;</span><br><span class="line">  array[<span class="number">0</span>].second = old_value;</span><br><span class="line">  array[<span class="number">1</span>].first = new_key;</span><br><span class="line">  array[<span class="number">1</span>].second = new_value;</span><br><span class="line">  <span class="built_in">SetSize</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::InsertNodeAfter</span><span class="params">(<span class="type">const</span> ValueType &amp;old_value, <span class="type">const</span> KeyType &amp; new_key, <span class="type">const</span> ValueType &amp;new_value)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> insert_index = <span class="built_in">ValueIndex</span>(old_value);</span><br><span class="line">  insert_index;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">GetSize</span>(); i &gt; insert_index; i--) &#123;</span><br><span class="line">    array[i] = array[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  array[insert_index] = MappingType&#123;new_key, new_value&#125;;</span><br><span class="line">  <span class="built_in">IncreaseSize</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">GetSize</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-MoveHalfTo函数"><a href="#2-5-MoveHalfTo函数" class="headerlink" title="2.5 MoveHalfTo函数"></a>2.5 MoveHalfTo函数</h3><ul>
<li><code>MoveHalfTo()</code>将old_node的右半部分array复制给new_node。</li>
<li><code>CopyNFrom()</code>将[items,items+size)复制到当前page的array最后一个键值对之后的空间。</li>
<li>找到调用<code>CopyNFrom()</code>函数的page的array中每个value指向的孩子结点，其父指针更新为调用该函数的page id。</li>
<li>注意，<code>UnpinPage()</code>的dirty参数要置为true，因为修改了page-&gt;data转为node后的<code>ParentPageId</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::MoveHalfTo</span><span class="params">(BPlusTreeInternalPage *recipient, BufferPoolManager *buffer_pool_manager)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> start_index = <span class="built_in">GetMinSize</span>();</span><br><span class="line">  <span class="type">int</span> move_num = <span class="built_in">GetSize</span>() - start_index;</span><br><span class="line">  recipient-&gt;<span class="built_in">CopyNFrom</span>(array + start_index, move_num, buffer_pool_manager);</span><br><span class="line">  <span class="built_in">IncreaseSize</span>(-move_num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">INDEX_TEMPLATE_ARGUMENTS</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">B_PLUS_TREE_INTERNAL_PAGE_TYPE::CopyNFrom</span><span class="params">(MappingType *items, <span class="type">int</span> size, BufferPoolManager *buffer_pool_manager)</span> </span>&#123;</span><br><span class="line">  std::<span class="built_in">copy</span>(items, items + size, array + <span class="built_in">GetSize</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">GetSize</span>(); i &lt; <span class="built_in">GetSize</span>() + size; i++) &#123;</span><br><span class="line">    Page *child_page = buffer_pool_manager-&gt;<span class="built_in">FetchPage</span>(<span class="built_in">ValueAt</span>(i));</span><br><span class="line">    BPlusTreePage *child_node = <span class="built_in">reinterpret_cast</span>&lt;BPlusTreePage *&gt;(child_page-&gt;<span class="built_in">GetData</span>());</span><br><span class="line">    child_node-&gt;<span class="built_in">SetParentPageId</span>(<span class="built_in">GetPageId</span>());</span><br><span class="line">    buffer_pool_manager-&gt;<span class="built_in">UnpinPage</span>(child_page-&gt;<span class="built_in">GetPageId</span>(), <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">IncreaseSize</span>(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Gradescope测试</strong></li>
</ul>
<img src="/2022/09/02/lab2/grade.jpg" class="">]]></content>
      <categories>
        <category>CMU15-445</category>
      </categories>
      <tags>
        <tag>数据库存储</tag>
        <tag>Algorithm</tag>
        <tag>B+ Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU15-445 lab01</title>
    <url>/2022/08/29/lab1/</url>
    <content><![CDATA[<style>
@import url(https://fonts.googleapis.com/css?family=Roboto);
blockquote {
 /* color:#888; */
 background-color: #f9f2f4;
 border-left: 0.2em solid #FA7298;
 padding: 1em 0.7em 1em 0.7em;
 position: relative;
 /* font-family: 'Roboto', sans-serif; */
 line-height: 150%;
 border-radius: 3px;
 /* text-indent: 35px; */
}
</style>
<h1 id="1-Task1-LRU-REPLACEMENT-POLICY"><a href="#1-Task1-LRU-REPLACEMENT-POLICY" class="headerlink" title="1. Task1 LRU REPLACEMENT POLICY"></a>1. Task1 LRU REPLACEMENT POLICY</h1><h2 id="0-任务描述"><a href="#0-任务描述" class="headerlink" title="0. 任务描述"></a>0. 任务描述</h2><p>这个任务要求我们实现在课堂上所描述的LRU算法。</p>
<p>你需要实现下面这些函数。请确保他们都是线程安全的。</p>
<ul>
<li><p><code>Victim(T*)</code> :  Remove the object that was accessed the least recently compared to all the elements being tracked by the Replacer, store its contents in the output parameter and return True. If the Replacer is empty return False.</p>
</li>
<li><p><code>Pin(T)</code> :This method should be called after a page is pinned to a frame in the BufferPoolManager. It should remove the frame containing the pinned page from the LRUReplacer.</p>
</li>
<li><p><code>Unpin(T)</code> : This method should be called when the pin_count of a page becomes 0. This method should add the frame containing the unpinned page to the LRUReplacer.</p>
</li>
<li><p><code>Size()</code> : This method returns the number of frames that are currently in the LRUReplacer.</p>
</li>
</ul>
<span id="more"></span>

<h2 id="1-LRU实现"><a href="#1-LRU实现" class="headerlink" title="1. LRU实现"></a>1. LRU实现</h2><h3 id="1-1-基本数据结构"><a href="#1-1-基本数据结构" class="headerlink" title="1.1 基本数据结构"></a>1.1 基本数据结构</h3><blockquote>
LRU 算法的设计原则是：如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。
</blockquote>


<ul>
<li>考虑到线程安全及并发错误， 需要在函数中加入<code>latch</code>锁。</li>
<li><code>capacity</code>表示replacer的容量。</li>
<li><code>lru_list</code>为双向链表，记录replacer的frame。</li>
<li>使用<code>lruMap</code>哈希表+双链表的结构，哈希表存储frame id以及指向<code>lru_list</code>内frame的begin指针，让插入和删除复杂度均为O(1)。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::mutex latch;  <span class="comment">// thread safety</span></span><br><span class="line">  <span class="type">size_t</span> capacity;   <span class="comment">// max number of pages LRUReplacer can handle</span></span><br><span class="line">  std::list&lt;<span class="type">frame_id_t</span>&gt; lru_list;</span><br><span class="line">  std::unordered_map&lt;<span class="type">frame_id_t</span>, std::list&lt;<span class="type">frame_id_t</span>&gt;::iterator&gt; lruMap;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-Victim-函数实现"><a href="#1-2-Victim-函数实现" class="headerlink" title="1.2 Victim 函数实现"></a>1.2 Victim 函数实现</h3><blockquote>
注意这里必须要加锁，以防止并发错误。
</blockquote>

<ul>
<li>使用<code>std::scoped_lock</code>c++17中的scope锁，它能够避免死锁发生，其构造函数能够自动进行上锁操作，析构函数会对互斥量进行解锁操作，保证线程安全。</li>
<li>如果replacer为空，意味着找不到牺牲页，返回<code>false</code>。</li>
<li>如果replacer非空，删除最久未使用的页面。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LRUReplacer::Victim</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> </span>&#123;</span><br><span class="line">  std::scoped_lock lock&#123;latch&#125;;</span><br><span class="line">  <span class="comment">// If empty, it means that no victim can be found.</span></span><br><span class="line">  <span class="keyword">if</span> (lruMap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Find the last frame and remove it.</span></span><br><span class="line">  *frame_id = lru_list.<span class="built_in">back</span>();</span><br><span class="line">  lruMap.<span class="built_in">erase</span>(*frame_id);</span><br><span class="line">  lru_list.<span class="built_in">pop_back</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-pin-函数实现"><a href="#1-3-pin-函数实现" class="headerlink" title="1.3 pin 函数实现"></a>1.3 pin 函数实现</h3><blockquote>
注意这里必须要加锁，以防止并发错误。
</blockquote>

<ul>
<li>pin的作用是标记该页（如正在使用），防止并发错误。</li>
<li>如果找到该frame, 将其从replacer中删除。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUReplacer::Pin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  std::scoped_lock lock&#123;latch&#125;;</span><br><span class="line">  <span class="comment">// Find the frame and pin it.</span></span><br><span class="line">  <span class="keyword">auto</span> it = lruMap.<span class="built_in">find</span>(frame_id);</span><br><span class="line">  <span class="keyword">if</span> (it != lruMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    lru_list.<span class="built_in">erase</span>(lruMap[frame_id]);</span><br><span class="line">    lruMap.<span class="built_in">erase</span>(frame_id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-unpin-函数实现"><a href="#1-4-unpin-函数实现" class="headerlink" title="1.4 unpin 函数实现"></a>1.4 unpin 函数实现</h3><blockquote>
注意这里必须要加锁，以防止并发错误。
</blockquote>

<ul>
<li>unpin的作用是取消标记，将该页加入replacer中。</li>
<li>如果在replacer中找不到该frame，且replacer不满，加入该frame。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LRUReplacer::Unpin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> </span>&#123;</span><br><span class="line">  std::scoped_lock lock&#123;latch&#125;;</span><br><span class="line">  <span class="comment">// If exist, do nothing.</span></span><br><span class="line">  <span class="keyword">auto</span> it = lruMap.<span class="built_in">find</span>(frame_id);</span><br><span class="line">  <span class="keyword">if</span> (it != lruMap.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if list size &gt;= capacity, do nothing</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Size</span>() &gt;= capacity) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// insert</span></span><br><span class="line">  lru_list.<span class="built_in">push_front</span>(frame_id);</span><br><span class="line">  lruMap.<span class="built_in">emplace</span>(frame_id, lru_list.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-Test"><a href="#1-5-Test" class="headerlink" title="1.5 Test"></a>1.5 Test</h3><ul>
<li><strong>检测语法及格式</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ make format</span><br><span class="line">$ make check-lint</span><br><span class="line">$ make check-clang-tidy</span><br><span class="line">$ make lru_replacer_test</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>测试</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./test/lru_replacer_test</span><br><span class="line">Running main() from gmock_main.cc</span><br><span class="line">[==========] Running 1 <span class="built_in">test</span> from 1 <span class="built_in">test</span> suite.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 1 <span class="built_in">test</span> from LRUReplacerTest</span><br><span class="line">[ RUN      ] LRUReplacerTest.SampleTest</span><br><span class="line">[       OK ] LRUReplacerTest.SampleTest (0 ms)</span><br><span class="line">[----------] 1 <span class="built_in">test</span> from LRUReplacerTest (0 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global <span class="built_in">test</span> environment tear-down</span><br><span class="line">[==========] 1 <span class="built_in">test</span> from 1 <span class="built_in">test</span> suite ran. (0 ms total)</span><br><span class="line">[  PASSED  ] 1 <span class="built_in">test</span>.</span><br></pre></td></tr></table></figure>
<h1 id="2-Task2-BUFFER-POOL-MANAGER"><a href="#2-Task2-BUFFER-POOL-MANAGER" class="headerlink" title="2. Task2 BUFFER POOL MANAGER"></a>2. Task2 BUFFER POOL MANAGER</h1><h2 id="0-任务描述-1"><a href="#0-任务描述-1" class="headerlink" title="0. 任务描述"></a>0. 任务描述</h2><p>接下来，您需要在系统中实现缓冲池管理器<code>(BufferPoolManager)</code>。<code>BufferPoolManager</code>负责从<code>DiskManager</code>获取数据库页面并将它们存储在内存中。<code>BufferPoolManage</code>还可以在有要求它这样做时，或者当它需要驱逐一个页以便为新页腾出空间时，将脏页写入磁盘。为了确保您的实现能够正确地与系统的其余部分一起工作，我们将为您提供一些已经填写好的功能。您也不需要实现实际读写数据到磁盘的代码(在我们的实现中称为<code>DiskManager</code>)。我们将为您提供这一功能。</p>
<p>系统中的所有内存页面均由<code>Page</code>对象表示。<code>BufferPoolManager</code>不需要了解这些页面的内容。 但是，作为系统开发人员，重要的是要了解Page对象只是缓冲池中用于存储内存的容器，因此并不特定于唯一页面。 也就是说，每个<code>Page</code>对象都包含一块内存，<code>DiskManager</code>会将其用作复制从磁盘读取的物理页面内容的位置。 <code>BufferPoolManager</code>将在将其来回移动到磁盘时重用相同的<code>Page</code>对象来存储数据。 这意味着在系统的整个生命周期中，相同的<code>Page</code>对象可能包含不同的物理页面。<code>Page</code>对象的标识符（<code>page_id</code>）跟踪其包含的物理页面。 如果<code>Page</code>对象不包含物理页面，则必须将其<code>page_id</code>设置为<code>INVALID_PAGE_ID</code>。</p>
<p>每个<code>Page</code>对象还维护一个计数器，以显示“固定”该页面的线程数。<code>BufferPoolManager</code>不允许释放固定的页面。每个<code>Page</code>对象还跟踪它的脏标记。您的工作是判断页面在解绑定之前是否已经被修改（修改则把脏标记置为1）。<code>BufferPoolManager</code>必须将脏页的内容写回磁盘，然后才能重用该对象。</p>
<p><code>BufferPoolManager</code>实现将使用在此分配的前面步骤中创建的<code>LRUReplacer</code>类。它将使用<code>LRUReplacer</code>来跟踪何时访问页对象，以便在必须释放一个帧以为从磁盘复制新的物理页腾出空间时，它可以决定取消哪个页对象</p>
<p>你需要实现在(src&#x2F;buffer&#x2F;buffer_pool_manager.cpp):的以下函数</p>
<ul>
<li><code>FetchPageImpl(page_id)</code></li>
<li><code>NewPageImpl(page_id)</code></li>
<li><code>UnpinPageImpl(page_id, is_dirty)</code></li>
<li><code>FlushPageImpl(page_id)</code></li>
<li><code>DeletePageImpl(page_id)</code></li>
<li><code>FlushAllPagesImpl()</code></li>
</ul>
<h2 id="1-BufferPool实现"><a href="#1-BufferPool实现" class="headerlink" title="1. BufferPool实现"></a>1. BufferPool实现</h2><h3 id="1-1-基本数据结构-1"><a href="#1-1-基本数据结构-1" class="headerlink" title="1.1 基本数据结构"></a>1.1 基本数据结构</h3><ul>
<li><code>pool_size_</code>表示缓冲池的最大容量。</li>
<li><code>*pages_</code>指向缓冲池中page数组，用<code>pages_ = new Page[pool_size_]</code>来初始化。</li>
<li><code>page_table_</code>是页表，page_id标识磁盘页，页表记录了该page在磁盘中的page_id和对应缓冲池中的frame_id。</li>
<li><code>free_list</code>里面存的是frame_id，具体来说就是还没有被分配的缓冲池的数组项</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Number of pages in the buffer pool. */</span></span><br><span class="line"><span class="type">size_t</span> pool_size_;</span><br><span class="line"><span class="comment">/** Array of buffer pool pages. */</span></span><br><span class="line">Page *pages_;</span><br><span class="line"><span class="comment">/** Page table for keeping track of buffer pool pages. */</span></span><br><span class="line">std::unordered_map&lt;<span class="type">page_id_t</span>, <span class="type">frame_id_t</span>&gt; page_table_;</span><br><span class="line"><span class="comment">/** List of free pages. */</span></span><br><span class="line">std::list&lt;<span class="type">frame_id_t</span>&gt; free_list_;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-UpdatePage函数实现"><a href="#1-2-UpdatePage函数实现" class="headerlink" title="1.2 UpdatePage函数实现"></a>1.2 UpdatePage函数实现</h3><ul>
<li>这是一个辅助函数，目的是更新页表中的数据。</li>
<li>如果是脏页，需要先将数据写回磁盘。</li>
<li>如果不是脏页，更新页表中的id。</li>
<li>最后清空该页，更新id。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BufferPoolManager::UpdatePage</span><span class="params">(Page *page, <span class="type">page_id_t</span> new_page_id, <span class="type">frame_id_t</span> new_frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (page-&gt;<span class="built_in">IsDirty</span>()) &#123;</span><br><span class="line">    disk_manager_-&gt;<span class="built_in">WritePage</span>(page-&gt;page_id_, page-&gt;data_);</span><br><span class="line">    page-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Put the new page in page table.</span></span><br><span class="line">  page_table_.<span class="built_in">erase</span>(page-&gt;page_id_);</span><br><span class="line">  <span class="keyword">if</span> (new_page_id != INVALID_PAGE_ID) &#123;</span><br><span class="line">    page_table_.<span class="built_in">emplace</span>(new_page_id, new_frame_id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make the page data empty.</span></span><br><span class="line">  page-&gt;<span class="built_in">ResetMemory</span>();</span><br><span class="line">  page-&gt;page_id_ = new_page_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-FindVictimPage函数实现"><a href="#1-2-FindVictimPage函数实现" class="headerlink" title="1.2 FindVictimPage函数实现"></a>1.2 FindVictimPage函数实现</h3><ul>
<li>这是一个辅助函数，目的是找到牺牲页。</li>
<li>如果<code>free_list_</code>不满，意味着buffer pool还有空位，找到<code>frame_id</code>。</li>
<li>如果缓冲池已满，调用LRU算法找牺牲页。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManager::FindVictimPage</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Buffer pool is not full. Get the frame id from free_list.</span></span><br><span class="line">  <span class="keyword">if</span> (!free_list_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    *frame_id = free_list_.<span class="built_in">front</span>();</span><br><span class="line">    free_list_.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Buffer pool is full. Use LRU algorithm.</span></span><br><span class="line">  <span class="keyword">return</span> replacer_-&gt;<span class="built_in">Victim</span>(frame_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-FetchPageImpl函数实现"><a href="#1-4-FetchPageImpl函数实现" class="headerlink" title="1.4 FetchPageImpl函数实现"></a>1.4 FetchPageImpl函数实现</h3><blockquote>
注意这里必须要加锁，以防止并发错误。
</blockquote>


<ul>
<li>如果能在<code>page_table_</code>页表中找到该页，调用<code>replacer</code>将其pin出。</li>
<li>如果找不到，说明该page不在缓冲池中，而在磁盘中，调用<code>FindVictimPage</code>在缓冲池中找到<code>frame</code>。</li>
<li>通过<code>frame_id</code>找到相应的<code>page</code>，更新数据，别忘了pin住该页。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Page *<span class="title">BufferPoolManager::FetchPageImpl</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.     Search the page table for the requested page (P).</span></span><br><span class="line">  <span class="comment">// 1.1    If P exists, pin it and return it immediately.</span></span><br><span class="line">  <span class="comment">// 1.2    If P does not exist, find a replacement page (R) from either the free list or the replacer.</span></span><br><span class="line">  <span class="comment">//        Note that pages are always found from the free list first.</span></span><br><span class="line">  <span class="comment">// 2.     If R is dirty, write it back to the disk.</span></span><br><span class="line">  <span class="comment">// 3.     Delete R from the page table and insert P.</span></span><br><span class="line">  <span class="comment">// 4.     Update P&#x27;s metadata, read in the page content from disk, and then return a pointer to P.</span></span><br><span class="line">  std::scoped_lock lock&#123;latch_&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> iter = page_table_.<span class="built_in">find</span>(page_id);</span><br><span class="line">  <span class="keyword">if</span> (iter != page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// Find the frame id through page table.</span></span><br><span class="line">    <span class="type">frame_id_t</span> frame_id = iter-&gt;second;</span><br><span class="line">    Page *page = &amp;pages_[frame_id];</span><br><span class="line">    <span class="comment">// Pin it and and record it in pin count.</span></span><br><span class="line">    replacer_-&gt;<span class="built_in">Pin</span>(frame_id);</span><br><span class="line">    page-&gt;pin_count_++;</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cannot find. It means that this page is in the disk.</span></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// Find the victim page and insert the disk page instead.</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">FindVictimPage</span>(&amp;frame_id)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find the page and get the frame id.</span></span><br><span class="line">  Page *page = &amp;pages_[frame_id];</span><br><span class="line">  <span class="built_in">UpdatePage</span>(page, page_id, frame_id);</span><br><span class="line">  disk_manager_-&gt;<span class="built_in">ReadPage</span>(page_id, page-&gt;data_);</span><br><span class="line">  <span class="comment">// pin it</span></span><br><span class="line">  replacer_-&gt;<span class="built_in">Pin</span>(frame_id);</span><br><span class="line">  page-&gt;pin_count_ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-UnpinPageImpl函数实现"><a href="#1-5-UnpinPageImpl函数实现" class="headerlink" title="1.5 UnpinPageImpl函数实现"></a>1.5 UnpinPageImpl函数实现</h3><blockquote>
注意这里必须要加锁，以防止并发错误。
</blockquote>


<ul>
<li>如果我们这个进程已经完成了对该页的操作。我们需要unpin。</li>
<li>如果该page在缓冲池中，将<code>pin_count</code>减一，如果<code>pin_count</code>为0，unpin该页.</li>
<li>标注该页为dirty。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManager::UnpinPageImpl</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty)</span> </span>&#123;</span><br><span class="line">  std::scoped_lock lock&#123;latch_&#125;;</span><br><span class="line">  <span class="keyword">auto</span> iter = page_table_.<span class="built_in">find</span>(page_id);</span><br><span class="line">  <span class="comment">// Cannot find the page in buffer pool.</span></span><br><span class="line">  <span class="keyword">if</span> (iter == page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Find the page.</span></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = iter-&gt;second;</span><br><span class="line">  Page *page = &amp;pages_[frame_id];</span><br><span class="line">  <span class="comment">// Check pin count.</span></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;pin_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Do unpin.</span></span><br><span class="line">  page-&gt;pin_count_--;</span><br><span class="line">  <span class="keyword">if</span> (page-&gt;pin_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">    replacer_-&gt;<span class="built_in">Unpin</span>(frame_id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_dirty) &#123;</span><br><span class="line">    page-&gt;is_dirty_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-FlushPageImpl函数实现"><a href="#1-6-FlushPageImpl函数实现" class="headerlink" title="1.6 FlushPageImpl函数实现"></a>1.6 FlushPageImpl函数实现</h3><blockquote>
注意这里必须要加锁，以防止并发错误。
</blockquote>


<ul>
<li>这个函数是要把一个page写入磁盘。</li>
<li>在缓冲中找到该页，调用<code>WritePage</code>，并标记该页非脏。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManager::FlushPageImpl</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Make sure you call DiskManager::WritePage!</span></span><br><span class="line">  std::scoped_lock lock&#123;latch_&#125;;</span><br><span class="line">  <span class="keyword">auto</span> iter = page_table_.<span class="built_in">find</span>(page_id);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (iter == page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = iter-&gt;second;</span><br><span class="line">  Page *page = &amp;pages_[frame_id];</span><br><span class="line">  <span class="comment">// Write the dirty page into disk.</span></span><br><span class="line">  disk_manager_-&gt;<span class="built_in">WritePage</span>(page-&gt;page_id_, page-&gt;data_);</span><br><span class="line">  page-&gt;is_dirty_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-NewPageImpl函数实现"><a href="#1-7-NewPageImpl函数实现" class="headerlink" title="1.7 NewPageImpl函数实现"></a>1.7 NewPageImpl函数实现</h3><blockquote>
注意这里必须要加锁，以防止并发错误。
</blockquote>


<ul>
<li>这个函数是要从<code>DiskManager</code>中分配一个新页到缓冲池。</li>
<li>在缓冲中找不到位置，且没有牺牲页，返回空指针。</li>
<li>找到<code>frame_id</code>， 更新数据，pin住该页。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Page *<span class="title">BufferPoolManager::NewPageImpl</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 0.   Make sure you call DiskManager::AllocatePage!</span></span><br><span class="line">  <span class="comment">// 1.   If all the pages in the buffer pool are pinned, return nullptr.</span></span><br><span class="line">  <span class="comment">// 2.   Pick a victim page P from either the free list or the replacer. Always pick from the free list first.</span></span><br><span class="line">  <span class="comment">// 3.   Update P&#x27;s metadata, zero out memory and add P to the page table.</span></span><br><span class="line">  <span class="comment">// 4.   Set the page ID output parameter. Return a pointer to P.</span></span><br><span class="line">  std::scoped_lock lock&#123;latch_&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">FindVictimPage</span>(&amp;frame_id)) &#123;  <span class="comment">// Delete page in free list.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Get the frame id.</span></span><br><span class="line">  *page_id = disk_manager_-&gt;<span class="built_in">AllocatePage</span>();</span><br><span class="line">  Page *page = &amp;pages_[frame_id];</span><br><span class="line">  <span class="comment">// Update and pin page.</span></span><br><span class="line">  <span class="built_in">UpdatePage</span>(page, *page_id, frame_id);</span><br><span class="line">  replacer_-&gt;<span class="built_in">Pin</span>(frame_id);</span><br><span class="line">  page-&gt;pin_count_ = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-8-DeletePageImpl函数实现"><a href="#1-8-DeletePageImpl函数实现" class="headerlink" title="1.8 DeletePageImpl函数实现"></a>1.8 DeletePageImpl函数实现</h3><blockquote>
注意这里必须要加锁，以防止并发错误。
</blockquote>


<ul>
<li>这里是删除缓冲池中的page。</li>
<li>在缓冲中找不到该page，返回true。</li>
<li>找到<code>frame_id</code>，若不是pin状态，删除该页。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">BufferPoolManager::DeletePageImpl</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 0.   Make sure you call DiskManager::DeallocatePage!</span></span><br><span class="line">  <span class="comment">// 1.   Search the page table for the requested page (P).</span></span><br><span class="line">  <span class="comment">// 1.   If P does not exist, return true.</span></span><br><span class="line">  <span class="comment">// 2.   If P exists, but has a non-zero pin-count, return false. Someone is using the page.</span></span><br><span class="line">  <span class="comment">// 3.   Otherwise, P can be deleted. Remove P from the page table, reset its metadata and return it to the free list.</span></span><br><span class="line">  std::scoped_lock lock&#123;latch_&#125;;</span><br><span class="line">  <span class="comment">// Cannot find the page.</span></span><br><span class="line">  <span class="keyword">auto</span> iter = page_table_.<span class="built_in">find</span>(page_id);</span><br><span class="line">  <span class="keyword">if</span> (iter == page_table_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Get the frame id.</span></span><br><span class="line">  <span class="type">frame_id_t</span> frame_id = iter-&gt;second;</span><br><span class="line">  Page *page = &amp;pages_[frame_id];</span><br><span class="line">  <span class="comment">// Canot delete pin page.</span></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;pin_count_ != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  disk_manager_-&gt;<span class="built_in">DeallocatePage</span>(page_id);</span><br><span class="line">  <span class="built_in">UpdatePage</span>(page, INVALID_PAGE_ID, frame_id);</span><br><span class="line">  free_list_.<span class="built_in">push_back</span>(frame_id);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-9-Test"><a href="#1-9-Test" class="headerlink" title="1.9 Test"></a>1.9 Test</h3><ul>
<li><strong>检测语法及格式</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> build</span><br><span class="line">$ make format</span><br><span class="line">$ make check-lint</span><br><span class="line">$ make check-clang-tidy</span><br><span class="line">$ make buffer_pool_manager_test</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>测试</strong></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./test/buffer_pool_manager_test </span><br><span class="line">Running main() from gmock_main.cc</span><br><span class="line">[==========] Running 2 tests from 1 <span class="built_in">test</span> suite.</span><br><span class="line">[----------] Global <span class="built_in">test</span> environment set-up.</span><br><span class="line">[----------] 2 tests from BufferPoolManagerTest</span><br><span class="line">[ RUN      ] BufferPoolManagerTest.BinaryDataTest</span><br><span class="line">[       OK ] BufferPoolManagerTest.BinaryDataTest (0 ms)</span><br><span class="line">[ RUN      ] BufferPoolManagerTest.SampleTest</span><br><span class="line">[       OK ] BufferPoolManagerTest.SampleTest (0 ms)</span><br><span class="line">[----------] 2 tests from BufferPoolManagerTest (1 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global <span class="built_in">test</span> environment tear-down</span><br><span class="line">[==========] 2 tests from 1 <span class="built_in">test</span> suite ran. (1 ms total)</span><br><span class="line">[  PASSED  ] 2 tests.</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>gradescope测试</strong></li>
</ul>
<img src="/2022/08/29/lab1/grade.png" class="">]]></content>
      <categories>
        <category>CMU15-445</category>
      </categories>
      <tags>
        <tag>LRU算法</tag>
        <tag>Buffer Pool</tag>
        <tag>数据库存储</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Count Partitions(整数划分)</title>
    <url>/2022/08/29/count-partition/</url>
    <content><![CDATA[<h1 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a><strong>问题描述：</strong></h1><img src="/2022/08/29/count-partition/par.png" class="">
<span id="more"></span>
<h1 id="思路："><a href="#思路：" class="headerlink" title="思路："></a><strong>思路：</strong></h1><h2 id="基本情况（Base-case）"><a href="#基本情况（Base-case）" class="headerlink" title="基本情况（Base case）"></a>基本情况（Base case）</h2><ul>
<li><strong>当n &#x3D; 0时， 仅有 0 &#x3D; 0一种划分，返回1</strong></li>
<li><strong>当n &lt; 0时， 递归过界，返回0</strong></li>
<li><strong>当k &#x3D; 0时， 无法划分，返回0</strong></li>
</ul>
<h2 id="递推方法-Recursive-calls"><a href="#递推方法-Recursive-calls" class="headerlink" title="递推方法(Recursive calls)"></a><strong>递推方法(Recursive calls)</strong></h2><ul>
<li><strong>Q(n,m)&#x3D;Q(n,m-1)+Q(n-m,m)</strong><br> 等式右边第一部分Q(n,m-1)表示被加数不包含m的分划的数目，第二部分表示被加数中包含（注意不是小于）m的分划的数目，因为如果确定了一个分划的被加数中包含m,则剩下的部分就是对n-m进行不超过m的划分。</li>
</ul>
<h1 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a><strong>代码如下：</strong></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_partitions</span>(<span class="params">n, k</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; count_partitions(5, 3)</span></span><br><span class="line"><span class="string">    5</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; count_partitions(6, 4)</span></span><br><span class="line"><span class="string">    9</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> n &lt; <span class="number">0</span> <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> count_partitions(n , k - <span class="number">1</span>) + count_partitions(n - k, k)</span><br></pre></td></tr></table></figure>

<h2 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 -m doctest count_partiton.py -v</span><br><span class="line">Trying:</span><br><span class="line">    count_partitions(5, 3)</span><br><span class="line">Expecting:</span><br><span class="line">    5</span><br><span class="line">ok</span><br><span class="line">Trying:</span><br><span class="line">    count_partitions(6, 4)</span><br><span class="line">Expecting:</span><br><span class="line">    9</span><br><span class="line">ok</span><br><span class="line">1 items had no tests:</span><br><span class="line">    count_partiton</span><br><span class="line">1 items passed all tests:</span><br><span class="line">   2 tests <span class="keyword">in</span> count_partiton.count_partitions</span><br><span class="line">2 tests <span class="keyword">in</span> 2 items.</span><br><span class="line">2 passed and 0 failed.</span><br><span class="line">Test passed.</span><br></pre></td></tr></table></figure>

<h1 id="递归树："><a href="#递归树：" class="headerlink" title="递归树："></a>递归树：</h1><img src="/2022/08/29/count-partition/tree.png" class="">]]></content>
      <categories>
        <category>CS基础知识</category>
      </categories>
  </entry>
</search>
